# Software Requirement Engineering Notes

## Software Requirement Engineering: Lecture 1 Breakdown

**Introduction**

This lecture introduces the field of Software Requirements Engineering (SRE). It emphasizes the crucial role of requirements in ensuring software projects are successful, meet stakeholder needs, and are delivered on time and within budget.

**Key Vocabulary:**

*   **Software Requirements Engineering (SRE):** The process of defining, documenting, and maintaining requirements in the software development lifecycle.
*   **Stakeholders:** Individuals, groups, or organizations who are affected by or can affect a software system.
*   **Requirement:** A condition or capability needed by a user to solve a problem or achieve an objective.
*   **SDLC:** Software Development Life Cycle

**Slide 1: Agenda**

The agenda outlines the key topics covered in the lecture:

*   Introduction to Software Requirement Engineering
*   Role of requirements in Software Engineering
*   The main risks of Requirements Engineering
*   Phases of the Requirements Engineering Process

**Slide 2: Software Engineering Goal**

The primary goal of software engineering is to develop quality software that:

*   Meets customers' real needs.
*   Is correct, reliable, maintainable, and user-friendly.
*   Has minimal total cost throughout its lifecycle.
*   Stays within budget.

*Analogy:* Think of building a house. The goal isn't just to build *any* house, but to build a house that meets the *specific* needs of the family who will live there (size, layout, style), is structurally sound and easy to maintain, and doesn't cost more than they can afford.

*Key Takeaway:* A "good" software product satisfies stakeholders' expectations regarding functionality, quality, and cost.

**Slide 3: Context: Stakeholders Environment**

This slide highlights that stakeholders are varied.

*Analogy:* Different people have different needs for a house. The parents might want a big kitchen, the kids might want a playroom, and the grandparents might want a ground-floor bedroom.

*Key Takeaway:* Software projects must consider the diverse needs and expectations of all stakeholders.

**Slides 4-6: Requirements in the Software Lifecycle**

These slides show the phases of the SDLC. While the number of phases varies (five, six, or seven), the key takeaway is that requirements are relevant throughout the entire software development lifecycle.

*Analogy:* Requirements are like the architectural blueprints for a house. They guide the construction process from start to finish, influencing everything from the foundation to the finishing touches.

*Key Takeaway:* Requirements impact every stage of software development, from initial planning to final deployment and maintenance.

**Slide 7: Introduction to Software Requirement Engineering**

This slide provides a formal definition of SRE: a critical phase focused on defining, documenting, and managing stakeholder needs and expectations. It emphasizes the systematic and iterative nature of understanding what the software should do, how it should behave, and what constraints it must operate within.

*Analogy:* SRE is like being a detective, gathering clues (requirements) from various sources (stakeholders) to build a complete picture of what the software needs to be.

*Key Takeaway:* SRE is about understanding and managing stakeholder needs to guide software development.

**Slides 8-10: Requirement: Definition**

These slides provide different definitions of a "requirement" from IEEE and Sommerville and Sawyer. The common thread is that a requirement is a specification of what should be implemented, describing how the system should behave, its properties, attributes, and any constraints on the development process.

*Key Vocabulary:*

*   **Condition:** A necessary state or situation.
*   **Capability:** The ability to do something.
*   **Constraint:** A limitation or restriction.

*Analogy:* A requirement is like a specific instruction in a recipe. It tells you exactly what ingredient to use, how much to use, and how to prepare it.

*Key Takeaway:* A requirement is a clear and documented statement of what the software must do or a characteristic it must have.

**Slide 11: Requirements Engineering: Definition**

This slide defines requirements engineering as the branch of software engineering concerned with real-world goals, functions, and constraints on software systems. It also addresses the relationship of these factors to precise specifications of software behavior and their evolution over time.

*Analogy:* Requirements engineering is like urban planning. It considers the needs of the community (stakeholders), the functions of buildings (software features), and the constraints of the environment (technology, budget) to create a functional and sustainable city (software system).

*Key Takeaway:* Requirements engineering bridges the gap between real-world needs and precise software specifications.

**Slide 12: By Proper Requirements Engineering We Can…**

This slide emphasizes the benefits of good requirements engineering:

*   Knowing what the system is supposed to do.
*   Keeping track of the status of requirements.
*   Determining the impact of a requirements change.

*Analogy:* Proper requirements engineering is like having a detailed map before starting a journey. It helps you know where you're going, track your progress, and adjust your route if needed.

*Key Takeaway:* Good RE leads to clarity, control, and adaptability in software development.

**Slide 13-14: Importance of RE**

These slides underscore the critical importance of requirements engineering. Deciding what to build is the hardest part of software development. Poor requirements engineering can cripple the resulting system and is difficult to rectify later. Good requirements engineering reduces costs and increases quality; poor requirements engineering leads to project failure.

*Analogy:* Requirements are the foundation of a building. If the foundation is weak, the entire building is at risk of collapsing.

*Key Takeaway:* Requirements engineering is the most critical and challenging aspect of software development, with significant consequences for success or failure.

**Slide 15: Significance**

Software requirements serve as the foundation for a successful software project, ensuring that the end-product meets the needs and expectations of its users and stakeholders.

*Analogy:* Requirements are the blueprint for a house; without them, the construction would be chaotic and unlikely to meet the owner's needs.

*Key Takeaway:* A good set of requirements is the basis for a successful software project.

**Slides 16-20: Role of Requirements in Software Engineering**

Requirements play a major role in:

*   **Communication:** Providing a common language for stakeholders.
*   **Guidance for Development:** Serving as a blueprint for developers.
*   **Scope Definition:** Defining the boundaries of the project.
*   **Project Planning:** Informing resource allocation and cost estimation.
*   **Quality Assurance:** Providing criteria for testing and validation.

*Analogy:* Requirements are like the constitution of a country. They provide a common understanding of the rules, guide the government in its actions, define the scope of its authority, inform budget decisions, and provide a basis for judging the legality of laws.

*Key Takeaway:* Requirements are essential for communication, development, scope management, planning, and quality assurance in software engineering.

**Slides 21-27: The Main Risks of Requirements Engineering**

These slides outline common risks associated with poor requirements engineering:

*   **Insufficient User Involvement:** Lack of user input leads to unmet needs.
*   **Creeping User Requirements:** Uncontrolled addition of new features causes scope creep and delays.
*   **Ambiguous Requirements:** Vague requirements lead to misunderstandings and errors.
*   **Gold Plating:** Adding unnecessary features wastes resources.
*   **Inaccurate Planning:** Underestimation of time and resources leads to poor quality.
*   **Overlooked User Classes:** Neglecting certain user groups leads to usability issues.

*Analogy:* These risks are like common construction mistakes. Insufficient planning is like building without blueprints. Creeping requirements are like constantly changing the design during construction. Ambiguous requirements are like using vague instructions that lead to misinterpretations. Gold plating is like adding unnecessary decorations that add cost and complexity.

*Key Takeaway:* Poor requirements engineering leads to various risks that can negatively impact project success.

**Slide 28: Phases of the Requirements Engineering Process**

This slide outlines the key phases of the requirements engineering process:

*   **Elicitation:** Gathering requirements from stakeholders.
*   **Analysis:** Understanding and classifying requirements.
*   **Specification:** Documenting requirements in a structured format.
*   **Validation:** Confirming the accuracy and completeness of requirements with stakeholders.

*Analogy:* This process is like conducting a scientific experiment: Elicitation is gathering data, analysis is interpreting the data, specification is writing a report, and validation is peer review.

*Key Takeaway:* The requirements engineering process involves eliciting, analyzing, specifying, and validating requirements.

**Slide 29: Why Requirements are Important?**

This slide is a summary of why requirements are important.

*Key Takeaway:* Requirements are the basis for a successful software project because they establish the foundation for what is to be built.

**Practice Quiz Questions:**

1.  Define Software Requirements Engineering (SRE).
2.  Explain the role of stakeholders in the requirements engineering process.
3.  List and describe three risks associated with poor requirements engineering.
4.  Outline the four phases of the requirements engineering process.
5.  Why is it important to have well-defined requirements in a software project? Provide at least three reasons.

**Answers to Practice Quiz Questions:**

1.  **Define Software Requirements Engineering (SRE).**

    Software Requirements Engineering (SRE) is the process of figuring out, writing down, and keeping track of what people want a software system to do. It's a systematic way to understand what the software should do, how it should act, and what limits it has to work within.

2.  **Explain the role of stakeholders in the requirements engineering process.**

    Stakeholders are anyone who cares about the software – customers, users, managers, developers, etc. Their role is super important because they're the ones who tell us what they need the software to do. We have to talk to them, understand their needs, and make sure the software meets those needs. If we don't involve them enough, we might build the wrong thing!

3.  **List and describe three risks associated with poor requirements engineering.**

    Okay, three risks of bad requirements engineering are:

    *   **Insufficient User Involvement:** If we don't talk to the users enough, we might build something they don't like or can't use. For example, an e-commerce site that's hard to navigate because the developers didn't ask users what they wanted.

    *   **Ambiguous Requirements:** If the requirements are not clear, the developers might misunderstand them and build the wrong thing. For example, if a requirement says "the system should be fast," but doesn't define what "fast" means, developers might have different ideas about how fast it should be.

    *   **Creeping User Requirements:** This is when people keep adding new features after the project has already started. This can make the project take longer, cost more, and be harder to finish.

4.  **Outline the four phases of the requirements engineering process.**

    The four phases are:

    *   **Elicitation:** This is where we gather requirements from stakeholders by interviewing them, doing surveys, or holding workshops.
    *   **Analysis:** This is where we try to understand the requirements, sort them into categories, and figure out how they relate to each other.
    *   **Specification:** This is where we write down the requirements in a clear and organized way, using documents and diagrams.
    *   **Validation:** This is where we ask the stakeholders to check if the requirements are correct, complete, and what they actually want.

5.  **Why is it important to have well-defined requirements in a software project? Provide at least three reasons.**

    It's important to have good requirements because:

    *   **It helps us build the right thing:** If we know exactly what the customer wants, we're more likely to build software that meets their needs.
    *   **It saves time and money:** If we have clear requirements, we're less likely to make mistakes that we have to fix later, which can save a lot of time and money.
    *   **It improves communication:** Good requirements provide a common language for everyone involved in the project, which helps avoid misunderstandings and makes it easier to work together.



## Software Requirement Engineering: Lecture 2 Breakdown

**Introduction**

This lecture builds upon the previous one by focusing on the essentials of software requirements, the characteristics of "good" requirements, and the motivations for professional software development.

**Slide 1-2: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Introduction to Software Requirements Engineering (RE): Essential Software Requirement
*   Good Requirements
*   Characteristics and Benefits of Requirement Engineering
*   Motivation, Professional s/w development

**Slides 3-4: Introduction to Software Requirements Engineering (RE)**

Software requirements are defined as the conditions or tasks a system must meet to fulfill user needs and objectives. They serve as the foundation for designing, developing, and testing the system.

*Analogy:* Imagine you're ordering a custom-built computer. The software requirements are like specifying the operating system (Windows, macOS, Linux), the specific programs you need (Microsoft Office, Adobe Creative Suite), and any special configurations (dual monitors, specific drivers).

*Key Takeaway:* Software requirements are the specific functionalities and conditions that a software system must satisfy to meet stakeholder expectations.

**Slides 5-7: Types of Software Requirements**

This section introduces three primary types of software requirements:

*   **Functional Requirements:** Define *what* the system should do (features, functionalities).
    *   *Example:* A login system with username/password validation, generating monthly financial reports, sending email notifications upon events.
    *   *Analogy:* For a car, functional requirements would be things like "must have a steering wheel," "must have brakes," and "must be able to accelerate to 60 mph."
*   **Non-Functional Requirements:** Define *how* the system performs (qualities like performance, reliability, usability, security).
    *   *Example:* Performance - "The system should handle 10,000 transactions per minute." Security - "All data must be encrypted during transmission." Usability - "The interface should be intuitive for users with basic computer skills."
    *   *Analogy:* For a car, non-functional requirements would be things like "must have good gas mileage," "must be safe in a crash," and "must be comfortable for long drives."
*   **Domain Requirements:** Specific to the context or industry.
    *   *Example:* Banking system - "Users can transfer funds only between accounts in the same bank." Healthcare - "Patient records must comply with HIPAA standards."
    *   *Analogy:* For a self-driving car, a domain requirement might be "must adhere to all local traffic laws."

*Key Vocabulary:*

*   **Functional Requirement:** A requirement that specifies a function that a system or system component must be able to perform.
*   **Non-Functional Requirement:** A requirement that specifies criteria that can be used to judge the operation of a system, rather than specific behaviors.
*   **Domain Requirement:** A requirement that is specific to a particular domain or industry.

*Key Takeaway:* Understanding the different types of requirements is crucial for comprehensive software development.

**Slide 8: Why Are Software Requirements Important?**

Software requirements are important because they:

*   Act as a bridge between stakeholders and developers.
*   Ensure all parties have a clear understanding of what the system should achieve.
*   Provide measurable criteria to evaluate the system's success.
*   Reduce misunderstandings and scope creep by defining what will and won’t be delivered.

*Analogy:* Requirements are like a contract between a builder and a homeowner. The contract specifies what the builder will build, how it will be built, and what materials will be used. This ensures that the homeowner gets the house they want, and the builder knows what to build.

*Key Takeaway:* Requirements are essential for communication, clarity, and success in software projects.

**Slides 9-10: Good Requirements**

Good requirements are well-defined, clearly articulated, and meet specific criteria to ensure they can guide the software development process effectively. They minimize ambiguity and miscommunication, leading to successful project outcomes.

*Analogy:* Good requirements are like clear and precise instructions for assembling a piece of furniture. They tell you exactly what parts you need, how to put them together, and what the finished product should look like.

*Key Takeaway:* Good requirements are essential for effective software development and successful project outcomes.

**Slides 11-20: Characteristics of Good Requirements**

These slides detail the key characteristics of good requirements:

1.  **Clear and Unambiguous:** Written in simple and precise language.
    *   *Example:* Instead of "The system should be fast," say, "The system must respond to user inputs within 2 seconds under normal conditions."
2.  **Complete:** Provides all necessary details, including context, constraints, and expected behavior.
    *   *Example:* "The system must allow users to reset their passwords using a verification email sent within 5 minutes of the request."
3.  **Consistent:** Does not conflict with other requirements or existing constraints.
    *   *Example:* A requirement specifying "Users must log in before accessing the application" should not conflict with another saying, "Users can browse as guests."
4.  **Feasible:** Realistic and achievable within project constraints.
    *   *Example:* Specifying that the system should handle 10,000 concurrent users is feasible only if the infrastructure supports it.
5.  **Testable (Verifiable):** Possible to validate through testing, inspection, or analysis.
    *   *Example:* "The system shall support 100 simultaneous user logins without errors" is testable.
6.  **Prioritized:** Ranked based on importance or urgency (e.g., high, medium, low priority).
    *   *Example:* Critical security features should be implemented before optional design enhancements.
7.  **Traceable:** Linked to its source (stakeholder need, business objective) and trackable throughout the development lifecycle.
    *   *Example:* A requirement tied to a regulatory standard like GDPR should include references to the specific clauses it addresses.
8.  **Modifiable:** Easy to update without affecting clarity or traceability.
    *   *Example:* Updating a requirement to include support for a new payment method should not invalidate the original intent.
9.  **Measurable:** Defines measurable outcomes to assess successful implementation.
    *   *Example:* "The system shall process 500 transactions per second under peak load conditions."

*Key Vocabulary:*

*   **Ambiguity:** Uncertainty or inexactness of meaning in language.
*   **Feasibility:** The state or degree of being easily or conveniently done.
*   **Traceability:** The ability to trace the history, application, or location of an item.

*Key Takeaway:* Striving for these characteristics results in high-quality requirements that guide effective software development.

**Slides 21-32: High-quality requirements- Benefits**

These slides outline the numerous benefits of high-quality requirements:

*   Reduced Ambiguity
*   Improved Communication
*   Accurate Cost Estimations
*   Enhanced Scope Management
*   Higher Quality Deliverables
*   Faster Development Cycles
*   Improved Testing
*   Easier Change Management
*   Enhanced Risk Management
*   Customer Satisfaction
*   Regulatory Compliance
*   Knowledge Preservation

*Analogy:* High-quality requirements are like having a well-organized toolbox. When you need a tool, you know exactly where it is, what it does, and how to use it. This makes your work faster, easier, and more efficient.

*Key Takeaway:* High-quality requirements lead to numerous benefits across the entire software development lifecycle.

**Slide 33: A Comparison!**

This slide illustrates a comparison of high-quality requirements versus low-quality requirements.

*Key Takeaway:* High-quality requirements are essential for a successful software project.

**Slides 34-36: Motivation for Requirement Engineering**

Understanding and documenting requirements properly:

*   Prevents cost overruns caused by late changes.
*   Ensures the system meets user needs and is fit for purpose.
*   Avoids failure of projects due to unclear or incomplete requirements.

*Analogy:* Requirements engineering is like doing your homework before starting a project. If you do your homework, you're more likely to succeed.

*Key Takeaway:* Proper requirements engineering is essential for preventing project failures and ensuring that the system meets user needs.

**Slide 37: Professional Software Development**

Professional software development emphasizes:

*   Collaboration with stakeholders.
*   Use of structured processes (e.g., Agile, Waterfall).
*   Compliance with standards and legal requirements.
*   Maintaining documentation for future maintenance and scaling.
*   It ensures that the end product aligns with business goals.
*   Helps in setting clear milestones and deliverables.

*Analogy:* Professional software development is like building a skyscraper. It requires careful planning, collaboration, and adherence to standards.

*Key Takeaway:* Professional software development emphasizes collaboration, structured processes, compliance, and documentation to ensure successful project outcomes.

**Practice Quiz Questions:**

1.  What is the difference between functional and non-functional requirements? Provide examples of each.
2.  List and explain five characteristics of good requirements.
3.  Explain the importance of traceability in requirements engineering.
4.  How do high-quality requirements contribute to customer satisfaction?
5.  Describe the key differences between professional software development and hobbyist development.

**Solutions to Practice Quiz Questions:**

1.  *Functional requirements* define what a system *should do* (its features). For example, "The system should allow users to create an account." *Non-functional requirements* define *how* the system performs, focusing on qualities like performance, security, and usability. For example, "The system should respond to user input within 1 second" (performance) or "The system must encrypt all sensitive data" (security).
2.  Five characteristics of good requirements:
    *   *Clear and Unambiguous:* The requirement should be easy to understand and have only one interpretation.
    *   *Complete:* The requirement should provide all necessary information.
    *   *Consistent:* The requirement should not conflict with other requirements.
    *   *Feasible:* The requirement should be achievable within the project's constraints.
    *   *Testable:* The requirement should be verifiable through testing or analysis.
3.  Traceability in requirements engineering is the ability to link a requirement back to its source (e.g., a stakeholder need, a business objective) and forward to its implementation (e.g., design documents, code, test cases). It's important because it helps ensure that all requirements are addressed, that changes are managed effectively, and that the system meets its intended goals.
4.  High-quality requirements contribute to customer satisfaction by ensuring that the final product aligns with the customer's needs and expectations. Clear and well-defined requirements reduce the risk of misunderstandings and errors, leading to a product that meets the customer's requirements, resulting in positive feedback and repeat business.
5.  Professional software development emphasizes collaboration with stakeholders, the use of structured processes (e.g., Agile, Waterfall), compliance with standards and legal requirements, and maintaining documentation for future maintenance and scaling. Hobbyist development, on the other hand, is often more informal, less structured, and less focused on collaboration and documentation. Professional development ensures alignment with business goals and sets clear milestones, while hobbyist development is often driven by personal interest and experimentation.

## Software Requirement Engineering: Lecture 4 Breakdown

**Introduction**

This lecture expands our understanding of software requirements by delving into the ethical considerations involved in software development, exploring additional types of requirements beyond functional and non-functional, and addressing common issues encountered during requirements engineering.

**Slides 1-2: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Software Ethics
*   Kinds of Software Requirements (Functional & Non-Functional)
*   Additional Types of Software Requirements
*   User & Customer Perspectives on Requirements
*   Common Requirement Issues

**Slides 3-6: Software Ethics**

Software ethics involves the moral and professional responsibilities of software engineers to ensure their work benefits society while minimizing harm. Key ethical concerns include:

*   Privacy & Data Protection (e.g., handling user data responsibly)
*   Security (e.g., preventing software vulnerabilities)
*   Fairness & Bias (e.g., avoiding discriminatory algorithms)
*   Accountability & Responsibility (e.g., ensuring software does not cause harm)

*Analogy:* Software ethics is like a doctor's Hippocratic Oath – a commitment to "do no harm" and to use your skills for the benefit of society.

*Key Takeaway:* Software engineers have a moral and professional obligation to develop software ethically, considering its impact on society and individuals.

**Slides 7-10: Importance of Software Ethics**

The importance of software ethics is highlighted through:

1.  Ensuring Responsible Software Development: Promotes accountability and consideration of societal implications.
    *   *Example:* Building inclusive systems that do not discriminate.
2.  Protecting Users' Rights and Privacy: Safeguards user data from misuse or unauthorized access.
    *   *Example:* Implementing encryption to secure sensitive user information.
3.  Reducing Harm from Unethical Software Use: Prevents negative consequences of poorly designed or unethical software.
    *   *Example:* Avoiding unsafe autonomous vehicles or biased AI systems.
4.  Building Trust with Stakeholders: Transparent and ethical practices strengthen relationships.
    *   *Example:* Ethical handling of customer feedback and privacy concerns fosters loyalty.

*Key Takeaway:* Ethical software development protects users, builds trust, and promotes responsible innovation.

**Slides 11-15: ACM/IEEE Code of Ethics**

This section refers to the ACM/IEEE Code of Ethics, highlighting key principles:

1.  Public Interest & Welfare: Prioritize societal well-being.
    *   *Example:* Ensuring software improves public safety, like emergency alert systems.
2.  Privacy & Data Protection: Safeguard user data and comply with regulations like GDPR.
    *   *Example:* Do not share or sell user data without explicit consent.
3.  Transparency & Accountability: Be honest about software capabilities, limitations, and potential risks.
    *   *Example:* Clearly informing users of the limitations of AI-driven recommendations.
4.  Professional Competence: Continuously improve skills to ensure high-quality, ethical solutions.
    *   *Example:* Regular training in secure coding practices.
5.  Avoiding Harm and Conflicts of Interest: Minimize risk of harm and avoid conflicts.
    *   *Example:* Refraining from introducing vulnerabilities to benefit competing organizations.

*Key Takeaway:* Adhering to ethical codes is crucial for responsible and trustworthy software development.

**Slides 16-17: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Software Ethics
*   Kinds of Software Requirements (Functional & Non-Functional)
*   Additional Types of Software Requirements
*   User & Customer Perspectives on Requirements
*   Common Requirement Issues

**Slides 18-20: Types of Software Requirements**

This section revisits functional, non-functional, and domain requirements, then introduces two new types:

*   **Inverse Requirements:** Describe what the system *should not* do.
*   **Design and Implementation Constraints:** Limitations on how the system can be designed and implemented.

*Key Vocabulary:*

*   **Inverse Requirement:** A requirement that specifies what the system should *not* do.
*   **Design Constraint:** A limitation on the design of the system.
*   **Implementation Constraint:** A limitation on how the system is implemented.

*Analogy:* When building a house, inverse requirements might be "the house should not be built on a floodplain," and design constraints might be "the house must adhere to local zoning regulations."

*Key Takeaway:* A comprehensive set of requirements includes not only what the system should do, but also what it should *not* do and any constraints on its design and implementation.

**Slides 21-22: Types of Software Requirements**

This section revisits functional, non-functional, and domain requirements, then introduces two new types:

*   **Inverse Requirements:** Describe what the system *should not* do.
*   **Design and Implementation Constraints:** Limitations on how the system can be designed and implemented.

*Key Vocabulary:*

*   **Inverse Requirement:** A requirement that specifies what the system should *not* do.
*   **Design Constraint:** A limitation on the design of the system.
*   **Implementation Constraint:** A limitation on how the system is implemented.

*Analogy:* When building a house, inverse requirements might be "the house should not be built on a floodplain," and design constraints might be "the house must adhere to local zoning regulations."

*Key Takeaway:* A comprehensive set of requirements includes not only what the system should do, but also what it should *not* do and any constraints on its design and implementation.

**Slides 23-24: Functional Requirements - 1**

Functional requirements describe what the system does.

*Key Takeaway:* Functional requirements describe the functionality of the system and the services it should provide.

**Slides 25-26: Functional Requirements - 2**

Functional requirements should be complete and consistent.

*Key Takeaway:* Functional requirements should be complete and consistent to minimize misinterpretations and assumptions.

**Slides 27-33: Functional Requirements Example # 1-4**

These slides provides examples of functional requirements.

*Key Takeaway:* Functional requirements should be specific and unambiguous to minimize misinterpretations and assumptions.

**Slides 34-36: Comments on Examples**

Incomplete and ambiguous requirements are open to multiple interpretations and assumptions.

*Key Takeaway:* Incomplete and ambiguous requirements are open to multiple interpretations and assumptions that can lead to poor quality or faulty software.

**Slides 37-39: Types of Software Requirements**

This section revisits functional, non-functional, and domain requirements, then introduces two new types:

*   **Inverse Requirements:** Describe what the system *should not* do.
*   **Design and Implementation Constraints:** Limitations on how the system can be designed and implemented.

*Key Vocabulary:*

*   **Inverse Requirement:** A requirement that specifies what the system should *not* do.
*   **Design Constraint:** A limitation on the design of the system.
*   **Implementation Constraint:** A limitation on how the system is implemented.

*Analogy:* When building a house, inverse requirements might be "the house should not be built on a floodplain," and design constraints might be "the house must adhere to local zoning regulations."

*Key Takeaway:* A comprehensive set of requirements includes not only what the system should do, but also what it should *not* do and any constraints on its design and implementation.

**Practice Quiz Questions:**

1.  Explain the importance of software ethics and provide two examples of ethical considerations in software development.
2.  Describe the ACM/IEEE Code of Ethics principle of "Transparency and Accountability" and provide an example of its application.
3.  What are inverse requirements? Give an example.
4.  What are design and implementation constraints? Give an example.
5.  Why are ambiguous requirements problematic?

**Solutions to Practice Quiz Questions:**

1.  Software ethics is important because it ensures that software is developed responsibly and does not cause harm to individuals or society. Examples of ethical considerations include:
    *   Protecting user privacy by implementing strong data security measures.
    *   Avoiding bias in algorithms to ensure fairness and prevent discrimination.
2.  The ACM/IEEE Code of Ethics principle of "Transparency and Accountability" emphasizes the importance of being honest about a software's capabilities, limitations, and potential risks. An example of its application is clearly informing users about the limitations of AI-driven recommendations, such as the possibility of inaccurate or biased suggestions.
3.  Inverse requirements specify what the system should *not* do. An example is, "The system shall not allow users to delete data from the database directly; all data deletion must go through an audit log."
4.  Design and implementation constraints are limitations on how the system can be designed and implemented. An example is, "The system must be implemented using the Python programming language" (implementation constraint) or "The user interface must conform to the company's established design guidelines" (design constraint).
5.  Ambiguous requirements are problematic because they are open to multiple interpretations and assumptions. This can lead to misunderstandings between stakeholders and developers, resulting in the development of poor-quality or faulty software products that do not meet the intended needs.



## Software Requirement Engineering: Lecture 5 Breakdown

**Introduction**

This lecture delves deeper into the various types of software requirements, emphasizing non-functional and domain requirements. It also explores the different perspectives of users and customers on requirements and addresses common issues in requirements engineering.

**Slides 1-2: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Types of Software Requirements
*   Software Ethics
*   Additional Types of Software Requirements
*   User & Customer Perspectives on Requirements
*   Common Requirement Issues

**Slides 3-7: Types of Software Requirements (Revisited)**

This section revisits the different types of software requirements already discussed:

*   Functional Requirements
*   Non-Functional Requirements
*   Domain Requirements
*   Inverse Requirements
*   Design and Implementation Constraints

*Key Takeaway:* A comprehensive understanding of these different types of requirements is crucial for successful software development.

**Slides 8-11: Non-Functional Requirements - 1 & 2**

Non-functional requirements relate to the system as a whole and include constraints on:

*   Timing
*   Performance
*   Reliability
*   Security
*   Maintainability
*   Accuracy
*   Development process and Standards, etc.

These requirements are often more critical than individual functional requirements and capture the emergent behavior of the system.

*Analogy:* If functional requirements are like the individual instruments in an orchestra, non-functional requirements are like the conductor, ensuring that all the instruments play together in harmony to create a beautiful and coherent sound.

*Key Takeaway:* Non-functional requirements are crucial for ensuring the overall quality and usability of the system.

**Slides 12-14: Non-Functional Requirements (cont..)**

Failure to meet a non-functional system requirement may make the whole system unusable. Non-functional requirements arise through user needs, budget constraints, organizational policies, interoperability needs, or external factors like safety regulations and privacy legislation.

*Analogy:* If the functional requirements are the ingredients of a cake, then the non-functional requirements are about the quality of those ingredients, the oven temperature, and the baking time. If any of these are off, the cake will be a disaster, no matter how good the ingredients are.

*Key Takeaway:* Non-functional requirements are critical for the success of the entire system.

**Slides 15-17: Non-Functional Requirements (cont..)**

Non-functional requirements are further categorized into:

*   Product Requirements
*   Organizational Requirements
*   External Requirements

*Key Takeaway:* Understanding these categories helps in classifying and managing non-functional requirements effectively.

**Slides 18-20: Product Requirements Examples**

The system shall allow one hundred thousand hits per minute on the website. The system shall not have downtime of more than one second for continuous execution of one thousand hours.

*Key Takeaway:* Product requirements define how the product should perform and its characteristics.

**Slide 21: Product Requirements**

Product requirements are further classified into:

*   Efficiency Requirements
*   Reliability Requirements
*   Portability Requirements
*   Usability Requirements
*   Performance Requirements
*   Space Requirements

*Key Takeaway:* Product requirements define the characteristics and qualities of the software product.

**Slides 22-24: Organizational Requirements**

*   Implementation Requirements
*   Standards Requirements
*   Organizational Requirements
*   Delivery Requirements

*Key Takeaway:* Organizational requirements address the standards, processes, and constraints within the development organization.

**Slides 25-26: Organizational Requirements Examples**

The system development process and deliverable documents shall conform to the ISO 9000. Any development work sub-contracted shall be carried out in accordance with Capability Maturity Model (CMM).

*Key Takeaway:* Organizational requirements ensure adherence to standards and best practices.

**Slides 27-29: External Requirements**

*   Ethical Requirements
*   Interoperability Requirements
*   External Requirements
*   Legislative Requirements
*   Privacy Requirements
*   Safety Requirements

*Key Takeaway:* External requirements address factors outside the organization that affect the system.

**Slides 30-31: External Requirements Examples**

The system shall not disclose any personal information about members of the library system to other members except system administrators. The system shall comply with the local and national laws regarding the use of software tools.

*Key Takeaway:* External requirements ensure compliance with laws, regulations, and ethical standards.

**Slides 32-34: Observations on Non-Functional Requirements (1/4)**

Non-functional requirements can be written to reflect general goals for the system, such as ease of use, recovery from failure, and rapid user response.

*Key Takeaway:* Non-functional requirements can be expressed as general goals, but this can lead to misinterpretations.

**Slides 35-37: Observations on Non-Functional Requirements (2/4)**

Goals are open to misinterpretation. Objective verification is difficult. The distinction between functional and non-functional is not always very clear.

*Key Takeaway:* Non-functional requirements should be written in a quantitative manner as much as possible.

**Slides 38-40: Observations on Non-Functional Requirements (3/4)**

Goals can be useful to designers and developers, as they give clues to them about priorities of the customers.

*Key Takeaway:* Goals can be useful to designers and developers, as they give clues to them about priorities of the customers.

**Slides 41-42: Observations on Non-Functional Requirements (4/4)**

Some negotiations must be done among different stakeholders to achieve an agreement in these situations. Non-functional requirements should be highlighted in the requirements document so that they can be used to build the architecture of the software product.

*Key Takeaway:* Non-functional requirements should be highlighted in the requirements document so that they can be used to build the architecture of the software product

**Slides 43-44: NFRs as Goals**

Non-functional requirements are sometimes written as general goals, which are difficult to verify.

*Key Takeaway:* They should be expressed quantitatively using metrics (measures) that can be objectively tested.

**Slides 45-46: Example: Goal converted into an NFR**

Goal (unverifiable): “The system should be easy to use by experienced controllers and should be organized in such a way that user errors are minimized.” Non-functional requirement (verifiable): “Experienced controllers shall be able to use all the system functions after a total of two hours’ training. After this training, the average number of errors made by experienced users shall not exceed two per day.”

*Key Takeaway:* This illustrates the importance of converting general goals into specific, measurable non-functional requirements.

**Slides 47-52: Metrics for Non-Functional Requirements (NFRs)**

These slides highlight the importance of using metrics to quantify non-functional requirements. Specific metrics will be detailed on the next slides.

*Key Takeaway:* Metrics are essential for objectively verifying non-functional requirements.

**Slide 53: Importance of Metrics used for NFRs**

With the help of measures (metrics), the NFRs can be verified quantitatively. It should also be noted that the cost of quantitatively verifying each NFR may be very high.

*Key Takeaway:* Metrics are essential for objectively verifying non-functional requirements.

**Slide 54: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Software Ethics
*   Kinds of Software Requirements (Functional & Non-Functional)
*   Additional Types of Software Requirements
*   User & Customer Perspectives on Requirements
*   Common Requirement Issues

**Slides 55-57: Types of Software Requirements**

This section revisits functional, non-functional, and domain requirements, then introduces two new types:

*   **Inverse Requirements:** Describe what the system *should not* do.
*   **Design and Implementation Constraints:** Limitations on how the system can be designed and implemented.

*Key Vocabulary:*

*   **Inverse Requirement:** A requirement that specifies what the system should *not* do.
*   **Design Constraint:** A limitation on the design of the system.
*   **Implementation Constraint:** A limitation on how the system is implemented.

*Analogy:* When building a house, inverse requirements might be "the house should not be built on a floodplain," and design constraints might be "the house must adhere to local zoning regulations."

*Key Takeaway:* A comprehensive set of requirements includes not only what the system should do, but also what it should *not* do and any constraints on its design and implementation.

**Slides 58-61: Domain Requirements - 1, 2, 3, 4**

Domain requirements come from the application domain and reflect fundamental characteristics of that domain. These can be both functional or non-functional requirements.

*Analogy:* Domain requirements are similar to the rules of the road for a self-driving car. They are specific to the domain of driving and must be followed to ensure safety and compliance.

*Key Takeaway:* Domain requirements are crucial for ensuring that the system is appropriate for its intended application.

**Slides 62-64: Types of Software Requirements**

This section revisits functional, non-functional, and domain requirements, then introduces two new types:

*   **Inverse Requirements:** Describe what the system *should not* do.
*   **Design and Implementation Constraints:** Limitations on how the system can be designed and implemented.

*Key Vocabulary:*

*   **Inverse Requirement:** A requirement that specifies what the system should *not* do.
*   **Design Constraint:** A limitation on the design of the system.
*   **Implementation Constraint:** A limitation on how the system is implemented.

*Analogy:* When building a house, inverse requirements might be "the house should not be built on a floodplain," and design constraints might be "the house must adhere to local zoning regulations."

*Key Takeaway:* A comprehensive set of requirements includes not only what the system should do, but also what it should *not* do and any constraints on its design and implementation.

**Slides 65-67: Inverse Requirements - 1, 2**

They explain what the system shall not do. Many people find it convenient to describe their needs in this manner.

*Analogy:* Inverse requirements are like the "do not" signs on a hiking trail. They tell you what you should not do to protect the environment and yourself.

*Key Takeaway:* Inverse requirements are important for clarifying the boundaries of the system and preventing unintended behavior.

**Slides 68-70: Types of Software Requirements**

This section revisits functional, non-functional, and domain requirements, then introduces two new types:

*   **Inverse Requirements:** Describe what the system *should not* do.
*   **Design and Implementation Constraints:** Limitations on how the system can be designed and implemented.

*Key Vocabulary:*

*   **Inverse Requirement:** A requirement that specifies what the system should *not* do.
*   **Design Constraint:** A limitation on the design of the system.
*   **Implementation Constraint:** A limitation on how the system is implemented.

*Analogy:* When building a house, inverse requirements might be "the house should not be built on a floodplain," and design constraints might be "the house must adhere to local zoning regulations."

*Key Takeaway:* A comprehensive set of requirements includes not only what the system should do, but also what it should *not* do and any constraints on its design and implementation.

**Slides 71-73: Design and Implementation Constraints - 1**

These are development guidelines within which the designer must work. These requirements can seriously limit design and implementation options.

*Analogy:* Design and implementation constraints are like the building codes that architects and builders must follow. They ensure that the building is safe and meets certain standards.

*Key Takeaway:* Design and implementation constraints are important for ensuring that the system is built in a consistent and maintainable way.

**Slides 74-75: Design and Implementation Constraints - Examples**

The system shall be developed using the Microsoft .Net platform. The system shall be developed using open-source tools and shall run on Linux operating system.

*Key Takeaway:* Design and implementation constraints provide specific guidance for the development team.

**Slides 76-77: Examples 1, 2**

These slides summarize the different types of requirements with examples.

*Key Takeaway:* A clear understanding of each requirement type is essential.

**Slides 78-80: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Software Ethics
*   Kinds of Software Requirements (Functional & Non-Functional)
*   Additional Types of Software Requirements
*   User & Customer Perspectives on Requirements
*   Common Requirement Issues

**Slides 81-83: Understanding Stakeholder Perspectives**

Users prioritize usability, performance, and accessibility, while customers prioritize security, compliance, and cost-effectiveness.

*Analogy:* Think of a restaurant. Users (diners) care about the taste of the food, the speed of service, and the atmosphere. Customers (owners) care about the cost of ingredients, the efficiency of the kitchen, and compliance with health regulations.

*Key Takeaway:* Balancing the needs of users and customers is a key challenge in requirements engineering.

**Slides 84-86: User & Customer Perspectives on Requirements**

Users expect an intuitive and easy-to-use interface, require fast and efficient system performance, and need accessibility features for diverse users. Customers focus on ensuring regulatory compliance, prioritize data security and financial constraints, and require cost-efficient and maintainable solutions.

*Key Takeaway:* Understanding and addressing the different perspectives of users and customers is essential for creating successful software.

**Slides 87-89: Challenges in Meeting Both Perspectives**

Balancing usability with security measures, aligning performance expectations with budget constraints, and ensuring compliance without compromising user experience.

*Key Takeaway:* Meeting the needs of both users and customers often requires trade-offs and compromises.

**Slides 90-92: Solutions for Aligning Perspectives**

Involve both users and customers in requirement gathering, use iterative design processes (e.g., prototyping and user feedback), and implement adaptive security and accessibility features.

*Key Takeaway:* Collaboration, iteration, and adaptive design are key strategies for aligning user and customer perspectives.

**Slide 93: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Software Ethics
*   Kinds of Software Requirements (Functional & Non-Functional)
*   Additional Types of Software Requirements
*   User & Customer Perspectives on Requirements
*   Common Requirement Issues

**Slides 94-96: Common Requirement Issues**

Common Requirement Issues: Already discussed in Lecture 02 Week 01. The main risks of Requirements Engineering: Insufficient user involvement, creeping user requirements, ambiguous requirements, gold plating, inaccurate planning, overlooked user classes.

*Key Takeaway:* Addressing these risks is crucial for successful requirements engineering.

**Slides 97-99: Common Requirement Problems & Solutions**

Best Practices for Contractual and Requirement Management: Clearly define the scope and deliverables in contracts, establish change control mechanisms, ensure stakeholder alignment before project initiation, and conduct regular reviews and updates to requirement documents.

*Key Takeaway:* Effective contractual and requirement management practices are essential for mitigating common requirement problems.

**Slide 100: Why Requirements are Important?**

This slide is a summary of why requirements are important.

*Key Takeaway:* Requirements are the basis for a successful software project because they establish the foundation for what is to be built.

**Practice Quiz Questions:**

1.  What are the three main categories of non-functional requirements? Give an example of each.
2.  Explain why it is important to quantify non-functional requirements. How can this be achieved?
3.  Describe the difference between domain requirements and inverse requirements, providing an example of each.
4.  Explain the differing priorities of users and customers in requirements gathering. Give an example of a potential conflict and how it can be resolved.
5.  List three best practices for managing requirements and preventing common problems.

**Solutions to Practice Quiz Questions:**

1.  The three main categories of non-functional requirements are:
    *   *Product Requirements:* Related to the characteristics of the software product itself. Example: "The system shall have a response time of less than 2 seconds for 90% of user requests."
    *   *Organizational Requirements:* Related to the development organization and its processes. Example: "The development team shall follow the company's coding standards."
    *   *External Requirements:* Related to external factors such as laws, regulations, and ethical considerations. Example: "The system shall comply with GDPR privacy regulations."
2.  It is important to quantify non-functional requirements because it makes them testable and verifiable. This can be achieved by using metrics, which are objective measures that can be used to assess whether the requirement has been met. For example, instead of saying "The system should be fast," you could say "The system shall have a response time of less than 2 seconds."
3.  *Domain requirements* are specific to the application domain and reflect fundamental characteristics of that domain. Example: "A banking system must comply with all applicable financial regulations." *Inverse requirements* specify what the system should *not* do. Example: "The system must not allow unauthorized access to sensitive data."
4.  Users typically prioritize usability, performance, and accessibility, while customers prioritize security, compliance, and cost-effectiveness. A potential conflict could arise if implementing strong security measures (customer priority) makes the system more difficult to use (user priority). This can be resolved by involving both users and customers in the design process and finding a balance between security and usability, such as implementing user-friendly authentication methods.
5.  Three best practices for managing requirements are:
    *   Clearly define the scope and deliverables in contracts.
    *   Establish change control mechanisms to manage changes to requirements.
    *   Ensure stakeholder alignment before project initiation to avoid conflicting requirements.


## Software Requirement Engineering: Lecture 6 Breakdown

**Introduction**

This lecture introduces various process models used in software development, contrasting traditional and agile approaches to requirements engineering. It also covers documenting requirements, measuring quality, and includes an activity and case study to illustrate the concepts.

**Slides 1-2: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Introduction to Process Models
*   Traditional vs. Agile Requirements Engineering
*   Documenting Requirements
*   Quality Measurement in Requirements Engineering
*   Activity & Case Study

**Slides 3-4: Introduction to Process Models**

Process models define structured methodologies for software development, helping in planning, executing, and managing software projects efficiently.

*Analogy:* Think of process models as different recipes for baking a cake. Each recipe (process model) provides a set of steps and guidelines to follow, but they vary in their approach and suitability for different types of cakes (software projects).

*Key Takeaway:* Process models provide a structured framework for software development.

**Slides 5-6: Introduction to Process Models**

Types of Process Models:

*   Waterfall Model
*   V-Model
*   Incremental Model
*   Spiral Model
*   Agile Model

*Key Takeaway:* There are various process models to choose from, each with its strengths and weaknesses.

**Slides 7-8: Introduction to Process Models - Waterfall Model**

The Waterfall Model follows a strict sequence: Requirements → Design → Implementation → Testing → Deployment → Maintenance. It's used in projects with well-defined and fixed requirements.

*Analogy:* The Waterfall Model is like an assembly line where each stage must be completed before moving on to the next.

*Key Takeaway:* The Waterfall Model is suitable for projects with stable requirements.

**Slides 9-10: Introduction to Process Models - Waterfall Model**

Strengths: Easy to manage, clear documentation. Weaknesses: Inflexible, difficult to accommodate changes. Example: Used in large-scale government or defense projects.

*Key Takeaway:* The Waterfall Model is easy to manage but lacks flexibility.

**Slides 11-12: Introduction to Process Models - V-Model**

The V-Model is an extension of the Waterfall model with a focus on testing at every stage. Each phase has a corresponding validation/testing phase.

*Analogy:* The V-Model is like a mirror image of the Waterfall model, with testing phases mirroring the development phases.

*Key Takeaway:* The V-Model emphasizes early defect detection through rigorous testing.

**Slides 13-14: Introduction to Process Models - V-Model**

Strengths: High reliability due to early defect detection. Weaknesses: Expensive and time-consuming. Example: Used in safety-critical systems like medical devices and avionics software.

*Key Takeaway:* The V-Model ensures high reliability but is expensive and time-consuming.

**Slides 15-16: Introduction to Process Models - Incremental Model**

The Incremental Model divides the project into smaller modules, each developed and tested incrementally. Each increment delivers part of the functionality.

*Analogy:* The Incremental Model is like building a house one room at a time, adding functionality with each increment.

*Key Takeaway:* The Incremental Model allows for early feedback and flexibility.

**Slides 17-18: Introduction to Process Models - Incremental Model**

Strengths: Allows early feedback, more flexible than Waterfall. Weaknesses: Requires proper planning to integrate all increments. Example: Used in developing web-based applications with evolving features.

*Key Takeaway:* The Incremental Model is flexible but requires careful planning for integration.

**Slides 19-20: Introduction to Process Models - Spiral Model**

The Spiral Model focuses on iterative risk assessment and mitigation. Each cycle includes Planning, Risk Analysis, Engineering, and Evaluation.

*Analogy:* The Spiral Model is like a continuous loop of planning, building, testing, and evaluating, with a focus on identifying and mitigating risks at each stage.

*Key Takeaway:* The Spiral Model is suitable for large and complex projects with high risks.

**Slides 21-22: Introduction to Process Models - Spiral Model**

Strengths: Handles risks proactively, suitable for large and complex projects. Weaknesses: Expensive, requires expertise in risk management. Example: Used in aerospace and banking systems where risk assessment is crucial.

*Key Takeaway:* The Spiral Model is risk-driven but expensive and requires risk management expertise.

**Slides 23-24: Introduction to Process Models - Agile Model**

The Agile Model encourages iterative development with continuous user feedback. Uses frameworks like Scrum, Kanban, and XP (Extreme Programming).

*Analogy:* The Agile Model is like a team of chefs continuously tasting and adjusting a dish based on customer feedback.

*Key Takeaway:* The Agile Model is flexible and emphasizes collaboration and user feedback.

**Slides 25-26: Introduction to Process Models - Agile Model**

Strengths: Flexible, high user involvement, quick delivery of functional software. Weaknesses: Requires strong collaboration, less suited for projects with strict regulations. Example: Used in startups and evolving software products like mobile applications.

*Key Takeaway:* The Agile Model is flexible and delivers software quickly but requires strong collaboration.

**Slides 27-28: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Introduction to Process Models
*   Traditional vs. Agile Requirements Engineering
*   Documenting Requirements
*   Quality Measurement in Requirements Engineering
*   Activity & Case Study

**Slides 29-30: Traditional vs. Agile Requirements Engineering**

Requirements engineering involves gathering, documenting, and managing system requirements. Two primary approaches exist: Traditional (Waterfall) and Agile (Scrum etc.).

*Analogy:* Traditional requirements engineering is like creating a detailed blueprint before building a house, while agile requirements engineering is like sketching a rough plan and adjusting it as you build.

*Key Takeaway:* The choice between traditional and agile approaches depends on the project's requirements and constraints.

**Slides 31-32: Traditional Requirements Engineering**

Characteristics: Follows a structured, sequential approach, detailed upfront documentation, requirements are fixed early, and minimal flexibility.

*Key Takeaway:* Traditional requirements engineering emphasizes upfront planning and documentation.

**Slides 33-34: Traditional Requirements Engineering**

Strengths: Well-suited for projects with clearly defined requirements, strong documentation and compliance support, predictable timeline and budget. Weaknesses: High risk of requirement changes being costly, late-stage feedback leads to expensive fixes, inflexible when requirements evolve.

*Key Takeaway:* Traditional requirements engineering is predictable but inflexible.

**Slides 35-36: Traditional Requirements Engineering**

Example: Used in government and large-scale enterprise systems where regulations require fixed documentation and predictability.

*Key Takeaway:* Traditional requirements engineering is suitable for projects with strict regulatory requirements.

**Slides 37-38: Agile Requirements Engineering**

Characteristics: Iterative and incremental development, requirements evolve based on continuous feedback, emphasizes working software over detailed documentation, and collaboration is crucial.

*Key Takeaway:* Agile requirements engineering emphasizes flexibility and collaboration.

**Slides 39-40: Agile Requirements Engineering**

Strengths: Adaptable to changing requirements and customer feedback, reduces risk by validating requirements through iterative development, delivers functional software quickly. Weaknesses: Requires close collaboration, can be difficult to maintain documentation consistency, not ideal for projects with strict regulatory requirements.

*Key Takeaway:* Agile requirements engineering is adaptable but requires strong collaboration.

**Slides 41-42: Agile Requirements Engineering**

Example: Startups and dynamic industries benefit from Agile due to evolving requirements and rapid iterations.

*Key Takeaway:* Agile requirements engineering is suitable for projects with evolving requirements.

**Slide 43: Comparison Table!**

This slide provides a comparison between agile vs. traditional requirements engineering.

*Key Takeaway:* A clear understanding of each requirement type is essential.

**Slides 44-45: Hybrid Approach: Best of Both Worlds**

Some projects use a Hybrid Model, integrating structured documentation from traditional methods with Agile’s adaptability.

*Analogy:* A hybrid approach is like building a house with a solid foundation (traditional) but using flexible interior design (agile).

*Key Takeaway:* A hybrid approach can combine the strengths of both traditional and agile methods.

**Slides 46-47: Case Study**

Agile vs. Waterfall in a Real-World Project: A banking company initially followed the Waterfall model to develop an online banking system. Challenges arose when unexpected regulatory changes required modifications. Switching to Agile for mobile banking allowed incremental changes and rapid adaptation.

*Key Takeaway:* This case study illustrates the benefits of Agile in dynamic environments.

**Slides 48-50: Case Study (1, 2)**

Analysis & Lessons Learned: Impact of Switching from Waterfall to Agile

*Key Takeaway:* The case study shows the benefits of switching from Waterfall to Agile.

**Slides 51-53: Case Study (3)**

Before the Switch (Waterfall Challenges): Regulatory changes caused major delays, late-stage modifications were expensive, and limited stakeholder involvement resulted in features that didn’t fully align with user needs.

*Key Takeaway:* The case study shows the challenges of using Waterfall in a dynamic environment.

**Slides 54-56: Case Study (4)**

After the Switch (Agile Benefits): Iterative development allowed faster adaptation, continuous feedback helped refine the mobile banking app, and shorter release cycles meant features were tested and deployed incrementally.

*Key Takeaway:* The case study shows the benefits of switching to Agile in a dynamic environment.

**Slide 57: Key Metrics for Success Evaluation (5)**

This slide lists key metrics for success evaluation.

*Key Takeaway:* Metrics are essential for objectively verifying non-functional requirements.

**Slide 58: Lessons Learned (6)**

Agile works best for evolving regulatory environments, allowing frequent updates. Waterfall is useful for initial large-scale system documentation but lacks flexibility.

*Key Takeaway:* Agile is better for evolving regulatory environments, while Waterfall is useful for initial large-scale system documentation but lacks flexibility.

**Slide 59: Final Outcome & Future Recommendations (7)**

The online banking system (built in Waterfall) serves as a stable, core backend. The mobile banking system (built in Agile) evolves continuously based on market needs. Future projects should evaluate complexity & regulatory risks before choosing a model.

*Key Takeaway:* The choice of process model should be based on the project's complexity and regulatory risks.

**Slide 60: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Introduction to Process Models
*   Traditional vs. Agile Requirements Engineering
*   Documenting Requirements
*   Quality Measurement in Requirements Engineering
*   Activity & Case Study

**Practice Quiz Questions:**

1.  Describe the key differences between the Waterfall and Agile process models. In what types of projects is each model most suitable?
2.  What are the strengths and weaknesses of traditional requirements engineering?
3.  What are the strengths and weaknesses of agile requirements engineering?
4.  What is a hybrid approach to requirements engineering, and why might it be beneficial?
5.  In the case study presented, why did the banking company switch from Waterfall to Agile for its mobile banking app? What lessons were learned?

**Solutions to Practice Quiz Questions:**

1.  *Waterfall* is a linear, sequential model with fixed requirements, suitable for projects with well-defined, stable requirements. *Agile* is an iterative, collaborative model with evolving requirements, suitable for projects with changing needs and a need for rapid feedback.
2.  *Strengths of Traditional RE:* Well-suited for projects with clearly defined requirements, strong documentation, predictable timeline and budget. *Weaknesses:* Inflexible, costly to change requirements, late-stage feedback.
3.  *Strengths of Agile RE:* Adaptable to changing requirements, iterative development, delivers functional software quickly. *Weaknesses:* Requires close collaboration, difficult to maintain documentation consistency, not ideal for strict regulatory requirements.
4.  A *hybrid approach* combines elements of both traditional and agile methods, such as using structured documentation upfront (traditional) and iterative development sprints (agile). It can be beneficial for large enterprises that need to balance compliance with the need for flexibility.
5.  The banking company switched to Agile for its mobile banking app because regulatory changes required frequent updates, and the mobile app needed to evolve based on customer feedback. Lessons learned included that Agile is best for evolving environments, while Waterfall is useful for initial documentation, and a hybrid approach can balance both.