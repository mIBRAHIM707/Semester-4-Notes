# Software Requirement Engineering Notes

## Software Requirement Engineering: Lecture 1 Breakdown

**Introduction**

This lecture introduces the field of Software Requirements Engineering (SRE). It emphasizes the crucial role of requirements in ensuring software projects are successful, meet stakeholder needs, and are delivered on time and within budget.

**Key Vocabulary:**

*   **Software Requirements Engineering (SRE):** The process of defining, documenting, and maintaining requirements in the software development lifecycle.
*   **Stakeholders:** Individuals, groups, or organizations who are affected by or can affect a software system.
*   **Requirement:** A condition or capability needed by a user to solve a problem or achieve an objective.
*   **SDLC:** Software Development Life Cycle

**Slide 1: Agenda**

The agenda outlines the key topics covered in the lecture:

*   Introduction to Software Requirement Engineering
*   Role of requirements in Software Engineering
*   The main risks of Requirements Engineering
*   Phases of the Requirements Engineering Process

**Slide 2: Software Engineering Goal**

The primary goal of software engineering is to develop quality software that:

*   Meets customers' real needs.
*   Is correct, reliable, maintainable, and user-friendly.
*   Has minimal total cost throughout its lifecycle.
*   Stays within budget.

*Analogy:* Think of building a house. The goal isn't just to build *any* house, but to build a house that meets the *specific* needs of the family who will live there (size, layout, style), is structurally sound and easy to maintain, and doesn't cost more than they can afford.

*Key Takeaway:* A "good" software product satisfies stakeholders' expectations regarding functionality, quality, and cost.

**Slide 3: Context: Stakeholders Environment**

This slide highlights that stakeholders are varied.

*Analogy:* Different people have different needs for a house. The parents might want a big kitchen, the kids might want a playroom, and the grandparents might want a ground-floor bedroom.

*Key Takeaway:* Software projects must consider the diverse needs and expectations of all stakeholders.

**Slides 4-6: Requirements in the Software Lifecycle**

These slides show the phases of the SDLC. While the number of phases varies (five, six, or seven), the key takeaway is that requirements are relevant throughout the entire software development lifecycle.

*Analogy:* Requirements are like the architectural blueprints for a house. They guide the construction process from start to finish, influencing everything from the foundation to the finishing touches.

*Key Takeaway:* Requirements impact every stage of software development, from initial planning to final deployment and maintenance.

**Slide 7: Introduction to Software Requirement Engineering**

This slide provides a formal definition of SRE: a critical phase focused on defining, documenting, and managing stakeholder needs and expectations. It emphasizes the systematic and iterative nature of understanding what the software should do, how it should behave, and what constraints it must operate within.

*Analogy:* SRE is like being a detective, gathering clues (requirements) from various sources (stakeholders) to build a complete picture of what the software needs to be.

*Key Takeaway:* SRE is about understanding and managing stakeholder needs to guide software development.

**Slides 8-10: Requirement: Definition**

These slides provide different definitions of a "requirement" from IEEE and Sommerville and Sawyer. The common thread is that a requirement is a specification of what should be implemented, describing how the system should behave, its properties, attributes, and any constraints on the development process.

*Key Vocabulary:*

*   **Condition:** A necessary state or situation.
*   **Capability:** The ability to do something.
*   **Constraint:** A limitation or restriction.

*Analogy:* A requirement is like a specific instruction in a recipe. It tells you exactly what ingredient to use, how much to use, and how to prepare it.

*Key Takeaway:* A requirement is a clear and documented statement of what the software must do or a characteristic it must have.

**Slide 11: Requirements Engineering: Definition**

This slide defines requirements engineering as the branch of software engineering concerned with real-world goals, functions, and constraints on software systems. It also addresses the relationship of these factors to precise specifications of software behavior and their evolution over time.

*Analogy:* Requirements engineering is like urban planning. It considers the needs of the community (stakeholders), the functions of buildings (software features), and the constraints of the environment (technology, budget) to create a functional and sustainable city (software system).

*Key Takeaway:* Requirements engineering bridges the gap between real-world needs and precise software specifications.

**Slide 12: By Proper Requirements Engineering We Can…**

This slide emphasizes the benefits of good requirements engineering:

*   Knowing what the system is supposed to do.
*   Keeping track of the status of requirements.
*   Determining the impact of a requirements change.

*Analogy:* Proper requirements engineering is like having a detailed map before starting a journey. It helps you know where you're going, track your progress, and adjust your route if needed.

*Key Takeaway:* Good RE leads to clarity, control, and adaptability in software development.

**Slide 13-14: Importance of RE**

These slides underscore the critical importance of requirements engineering. Deciding what to build is the hardest part of software development. Poor requirements engineering can cripple the resulting system and is difficult to rectify later. Good requirements engineering reduces costs and increases quality; poor requirements engineering leads to project failure.

*Analogy:* Requirements are the foundation of a building. If the foundation is weak, the entire building is at risk of collapsing.

*Key Takeaway:* Requirements engineering is the most critical and challenging aspect of software development, with significant consequences for success or failure.

**Slide 15: Significance**

Software requirements serve as the foundation for a successful software project, ensuring that the end-product meets the needs and expectations of its users and stakeholders.

*Analogy:* Requirements are the blueprint for a house; without them, the construction would be chaotic and unlikely to meet the owner's needs.

*Key Takeaway:* A good set of requirements is the basis for a successful software project.

**Slides 16-20: Role of Requirements in Software Engineering**

Requirements play a major role in:

*   **Communication:** Providing a common language for stakeholders.
*   **Guidance for Development:** Serving as a blueprint for developers.
*   **Scope Definition:** Defining the boundaries of the project.
*   **Project Planning:** Informing resource allocation and cost estimation.
*   **Quality Assurance:** Providing criteria for testing and validation.

*Analogy:* Requirements are like the constitution of a country. They provide a common understanding of the rules, guide the government in its actions, define the scope of its authority, inform budget decisions, and provide a basis for judging the legality of laws.

*Key Takeaway:* Requirements are essential for communication, development, scope management, planning, and quality assurance in software engineering.

**Slides 21-27: The Main Risks of Requirements Engineering**

These slides outline common risks associated with poor requirements engineering:

*   **Insufficient User Involvement:** Lack of user input leads to unmet needs.
*   **Creeping User Requirements:** Uncontrolled addition of new features causes scope creep and delays.
*   **Ambiguous Requirements:** Vague requirements lead to misunderstandings and errors.
*   **Gold Plating:** Adding unnecessary features wastes resources.
*   **Inaccurate Planning:** Underestimation of time and resources leads to poor quality.
*   **Overlooked User Classes:** Neglecting certain user groups leads to usability issues.

*Analogy:* These risks are like common construction mistakes. Insufficient planning is like building without blueprints. Creeping requirements are like constantly changing the design during construction. Ambiguous requirements are like using vague instructions that lead to misinterpretations. Gold plating is like adding unnecessary decorations that add cost and complexity.

*Key Takeaway:* Poor requirements engineering leads to various risks that can negatively impact project success.

**Slide 28: Phases of the Requirements Engineering Process**

This slide outlines the key phases of the requirements engineering process:

*   **Elicitation:** Gathering requirements from stakeholders.
*   **Analysis:** Understanding and classifying requirements.
*   **Specification:** Documenting requirements in a structured format.
*   **Validation:** Confirming the accuracy and completeness of requirements with stakeholders.

*Analogy:* This process is like conducting a scientific experiment: Elicitation is gathering data, analysis is interpreting the data, specification is writing a report, and validation is peer review.

*Key Takeaway:* The requirements engineering process involves eliciting, analyzing, specifying, and validating requirements.

**Slide 29: Why Requirements are Important?**

This slide is a summary of why requirements are important.

*Key Takeaway:* Requirements are the basis for a successful software project because they establish the foundation for what is to be built.

**Practice Quiz Questions:**

1.  Define Software Requirements Engineering (SRE).
2.  Explain the role of stakeholders in the requirements engineering process.
3.  List and describe three risks associated with poor requirements engineering.
4.  Outline the four phases of the requirements engineering process.
5.  Why is it important to have well-defined requirements in a software project? Provide at least three reasons.

**Answers to Practice Quiz Questions:**

1.  **Define Software Requirements Engineering (SRE).**

    Software Requirements Engineering (SRE) is the process of figuring out, writing down, and keeping track of what people want a software system to do. It's a systematic way to understand what the software should do, how it should act, and what limits it has to work within.

2.  **Explain the role of stakeholders in the requirements engineering process.**

    Stakeholders are anyone who cares about the software – customers, users, managers, developers, etc. Their role is super important because they're the ones who tell us what they need the software to do. We have to talk to them, understand their needs, and make sure the software meets those needs. If we don't involve them enough, we might build the wrong thing!

3.  **List and describe three risks associated with poor requirements engineering.**

    Okay, three risks of bad requirements engineering are:

    *   **Insufficient User Involvement:** If we don't talk to the users enough, we might build something they don't like or can't use. For example, an e-commerce site that's hard to navigate because the developers didn't ask users what they wanted.

    *   **Ambiguous Requirements:** If the requirements are not clear, the developers might misunderstand them and build the wrong thing. For example, if a requirement says "the system should be fast," but doesn't define what "fast" means, developers might have different ideas about how fast it should be.

    *   **Creeping User Requirements:** This is when people keep adding new features after the project has already started. This can make the project take longer, cost more, and be harder to finish.

4.  **Outline the four phases of the requirements engineering process.**

    The four phases are:

    *   **Elicitation:** This is where we gather requirements from stakeholders by interviewing them, doing surveys, or holding workshops.
    *   **Analysis:** This is where we try to understand the requirements, sort them into categories, and figure out how they relate to each other.
    *   **Specification:** This is where we write down the requirements in a clear and organized way, using documents and diagrams.
    *   **Validation:** This is where we ask the stakeholders to check if the requirements are correct, complete, and what they actually want.

5.  **Why is it important to have well-defined requirements in a software project? Provide at least three reasons.**

    It's important to have good requirements because:

    *   **It helps us build the right thing:** If we know exactly what the customer wants, we're more likely to build software that meets their needs.
    *   **It saves time and money:** If we have clear requirements, we're less likely to make mistakes that we have to fix later, which can save a lot of time and money.
    *   **It improves communication:** Good requirements provide a common language for everyone involved in the project, which helps avoid misunderstandings and makes it easier to work together.



## Software Requirement Engineering: Lecture 2 Breakdown

**Introduction**

This lecture builds upon the previous one by focusing on the essentials of software requirements, the characteristics of "good" requirements, and the motivations for professional software development.

**Slide 1-2: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Introduction to Software Requirements Engineering (RE): Essential Software Requirement
*   Good Requirements
*   Characteristics and Benefits of Requirement Engineering
*   Motivation, Professional s/w development

**Slides 3-4: Introduction to Software Requirements Engineering (RE)**

Software requirements are defined as the conditions or tasks a system must meet to fulfill user needs and objectives. They serve as the foundation for designing, developing, and testing the system.

*Analogy:* Imagine you're ordering a custom-built computer. The software requirements are like specifying the operating system (Windows, macOS, Linux), the specific programs you need (Microsoft Office, Adobe Creative Suite), and any special configurations (dual monitors, specific drivers).

*Key Takeaway:* Software requirements are the specific functionalities and conditions that a software system must satisfy to meet stakeholder expectations.

**Slides 5-7: Types of Software Requirements**

This section introduces three primary types of software requirements:

*   **Functional Requirements:** Define *what* the system should do (features, functionalities).
    *   *Example:* A login system with username/password validation, generating monthly financial reports, sending email notifications upon events.
    *   *Analogy:* For a car, functional requirements would be things like "must have a steering wheel," "must have brakes," and "must be able to accelerate to 60 mph."
*   **Non-Functional Requirements:** Define *how* the system performs (qualities like performance, reliability, usability, security).
    *   *Example:* Performance - "The system should handle 10,000 transactions per minute." Security - "All data must be encrypted during transmission." Usability - "The interface should be intuitive for users with basic computer skills."
    *   *Analogy:* For a car, non-functional requirements would be things like "must have good gas mileage," "must be safe in a crash," and "must be comfortable for long drives."
*   **Domain Requirements:** Specific to the context or industry.
    *   *Example:* Banking system - "Users can transfer funds only between accounts in the same bank." Healthcare - "Patient records must comply with HIPAA standards."
    *   *Analogy:* For a self-driving car, a domain requirement might be "must adhere to all local traffic laws."

*Key Vocabulary:*

*   **Functional Requirement:** A requirement that specifies a function that a system or system component must be able to perform.
*   **Non-Functional Requirement:** A requirement that specifies criteria that can be used to judge the operation of a system, rather than specific behaviors.
*   **Domain Requirement:** A requirement that is specific to a particular domain or industry.

*Key Takeaway:* Understanding the different types of requirements is crucial for comprehensive software development.

**Slide 8: Why Are Software Requirements Important?**

Software requirements are important because they:

*   Act as a bridge between stakeholders and developers.
*   Ensure all parties have a clear understanding of what the system should achieve.
*   Provide measurable criteria to evaluate the system's success.
*   Reduce misunderstandings and scope creep by defining what will and won’t be delivered.

*Analogy:* Requirements are like a contract between a builder and a homeowner. The contract specifies what the builder will build, how it will be built, and what materials will be used. This ensures that the homeowner gets the house they want, and the builder knows what to build.

*Key Takeaway:* Requirements are essential for communication, clarity, and success in software projects.

**Slides 9-10: Good Requirements**

Good requirements are well-defined, clearly articulated, and meet specific criteria to ensure they can guide the software development process effectively. They minimize ambiguity and miscommunication, leading to successful project outcomes.

*Analogy:* Good requirements are like clear and precise instructions for assembling a piece of furniture. They tell you exactly what parts you need, how to put them together, and what the finished product should look like.

*Key Takeaway:* Good requirements are essential for effective software development and successful project outcomes.

**Slides 11-20: Characteristics of Good Requirements**

These slides detail the key characteristics of good requirements:

1.  **Clear and Unambiguous:** Written in simple and precise language.
    *   *Example:* Instead of "The system should be fast," say, "The system must respond to user inputs within 2 seconds under normal conditions."
2.  **Complete:** Provides all necessary details, including context, constraints, and expected behavior.
    *   *Example:* "The system must allow users to reset their passwords using a verification email sent within 5 minutes of the request."
3.  **Consistent:** Does not conflict with other requirements or existing constraints.
    *   *Example:* A requirement specifying "Users must log in before accessing the application" should not conflict with another saying, "Users can browse as guests."
4.  **Feasible:** Realistic and achievable within project constraints.
    *   *Example:* Specifying that the system should handle 10,000 concurrent users is feasible only if the infrastructure supports it.
5.  **Testable (Verifiable):** Possible to validate through testing, inspection, or analysis.
    *   *Example:* "The system shall support 100 simultaneous user logins without errors" is testable.
6.  **Prioritized:** Ranked based on importance or urgency (e.g., high, medium, low priority).
    *   *Example:* Critical security features should be implemented before optional design enhancements.
7.  **Traceable:** Linked to its source (stakeholder need, business objective) and trackable throughout the development lifecycle.
    *   *Example:* A requirement tied to a regulatory standard like GDPR should include references to the specific clauses it addresses.
8.  **Modifiable:** Easy to update without affecting clarity or traceability.
    *   *Example:* Updating a requirement to include support for a new payment method should not invalidate the original intent.
9.  **Measurable:** Defines measurable outcomes to assess successful implementation.
    *   *Example:* "The system shall process 500 transactions per second under peak load conditions."

*Key Vocabulary:*

*   **Ambiguity:** Uncertainty or inexactness of meaning in language.
*   **Feasibility:** The state or degree of being easily or conveniently done.
*   **Traceability:** The ability to trace the history, application, or location of an item.

*Key Takeaway:* Striving for these characteristics results in high-quality requirements that guide effective software development.

**Slides 21-32: High-quality requirements- Benefits**

These slides outline the numerous benefits of high-quality requirements:

*   Reduced Ambiguity
*   Improved Communication
*   Accurate Cost Estimations
*   Enhanced Scope Management
*   Higher Quality Deliverables
*   Faster Development Cycles
*   Improved Testing
*   Easier Change Management
*   Enhanced Risk Management
*   Customer Satisfaction
*   Regulatory Compliance
*   Knowledge Preservation

*Analogy:* High-quality requirements are like having a well-organized toolbox. When you need a tool, you know exactly where it is, what it does, and how to use it. This makes your work faster, easier, and more efficient.

*Key Takeaway:* High-quality requirements lead to numerous benefits across the entire software development lifecycle.

**Slide 33: A Comparison!**

This slide illustrates a comparison of high-quality requirements versus low-quality requirements.

*Key Takeaway:* High-quality requirements are essential for a successful software project.

**Slides 34-36: Motivation for Requirement Engineering**

Understanding and documenting requirements properly:

*   Prevents cost overruns caused by late changes.
*   Ensures the system meets user needs and is fit for purpose.
*   Avoids failure of projects due to unclear or incomplete requirements.

*Analogy:* Requirements engineering is like doing your homework before starting a project. If you do your homework, you're more likely to succeed.

*Key Takeaway:* Proper requirements engineering is essential for preventing project failures and ensuring that the system meets user needs.

**Slide 37: Professional Software Development**

Professional software development emphasizes:

*   Collaboration with stakeholders.
*   Use of structured processes (e.g., Agile, Waterfall).
*   Compliance with standards and legal requirements.
*   Maintaining documentation for future maintenance and scaling.
*   It ensures that the end product aligns with business goals.
*   Helps in setting clear milestones and deliverables.

*Analogy:* Professional software development is like building a skyscraper. It requires careful planning, collaboration, and adherence to standards.

*Key Takeaway:* Professional software development emphasizes collaboration, structured processes, compliance, and documentation to ensure successful project outcomes.

**Practice Quiz Questions:**

1.  What is the difference between functional and non-functional requirements? Provide examples of each.
2.  List and explain five characteristics of good requirements.
3.  Explain the importance of traceability in requirements engineering.
4.  How do high-quality requirements contribute to customer satisfaction?
5.  Describe the key differences between professional software development and hobbyist development.

**Solutions to Practice Quiz Questions:**

1.  *Functional requirements* define what a system *should do* (its features). For example, "The system should allow users to create an account." *Non-functional requirements* define *how* the system performs, focusing on qualities like performance, security, and usability. For example, "The system should respond to user input within 1 second" (performance) or "The system must encrypt all sensitive data" (security).
2.  Five characteristics of good requirements:
    *   *Clear and Unambiguous:* The requirement should be easy to understand and have only one interpretation.
    *   *Complete:* The requirement should provide all necessary information.
    *   *Consistent:* The requirement should not conflict with other requirements.
    *   *Feasible:* The requirement should be achievable within the project's constraints.
    *   *Testable:* The requirement should be verifiable through testing or analysis.
3.  Traceability in requirements engineering is the ability to link a requirement back to its source (e.g., a stakeholder need, a business objective) and forward to its implementation (e.g., design documents, code, test cases). It's important because it helps ensure that all requirements are addressed, that changes are managed effectively, and that the system meets its intended goals.
4.  High-quality requirements contribute to customer satisfaction by ensuring that the final product aligns with the customer's needs and expectations. Clear and well-defined requirements reduce the risk of misunderstandings and errors, leading to a product that meets the customer's requirements, resulting in positive feedback and repeat business.
5.  Professional software development emphasizes collaboration with stakeholders, the use of structured processes (e.g., Agile, Waterfall), compliance with standards and legal requirements, and maintaining documentation for future maintenance and scaling. Hobbyist development, on the other hand, is often more informal, less structured, and less focused on collaboration and documentation. Professional development ensures alignment with business goals and sets clear milestones, while hobbyist development is often driven by personal interest and experimentation.

## Software Requirement Engineering: Lecture 4 Breakdown

**Introduction**

This lecture expands our understanding of software requirements by delving into the ethical considerations involved in software development, exploring additional types of requirements beyond functional and non-functional, and addressing common issues encountered during requirements engineering.

**Slides 1-2: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Software Ethics
*   Kinds of Software Requirements (Functional & Non-Functional)
*   Additional Types of Software Requirements
*   User & Customer Perspectives on Requirements
*   Common Requirement Issues

**Slides 3-6: Software Ethics**

Software ethics involves the moral and professional responsibilities of software engineers to ensure their work benefits society while minimizing harm. Key ethical concerns include:

*   Privacy & Data Protection (e.g., handling user data responsibly)
*   Security (e.g., preventing software vulnerabilities)
*   Fairness & Bias (e.g., avoiding discriminatory algorithms)
*   Accountability & Responsibility (e.g., ensuring software does not cause harm)

*Analogy:* Software ethics is like a doctor's Hippocratic Oath – a commitment to "do no harm" and to use your skills for the benefit of society.

*Key Takeaway:* Software engineers have a moral and professional obligation to develop software ethically, considering its impact on society and individuals.

**Slides 7-10: Importance of Software Ethics**

The importance of software ethics is highlighted through:

1.  Ensuring Responsible Software Development: Promotes accountability and consideration of societal implications.
    *   *Example:* Building inclusive systems that do not discriminate.
2.  Protecting Users' Rights and Privacy: Safeguards user data from misuse or unauthorized access.
    *   *Example:* Implementing encryption to secure sensitive user information.
3.  Reducing Harm from Unethical Software Use: Prevents negative consequences of poorly designed or unethical software.
    *   *Example:* Avoiding unsafe autonomous vehicles or biased AI systems.
4.  Building Trust with Stakeholders: Transparent and ethical practices strengthen relationships.
    *   *Example:* Ethical handling of customer feedback and privacy concerns fosters loyalty.

*Key Takeaway:* Ethical software development protects users, builds trust, and promotes responsible innovation.

**Slides 11-15: ACM/IEEE Code of Ethics**

This section refers to the ACM/IEEE Code of Ethics, highlighting key principles:

1.  Public Interest & Welfare: Prioritize societal well-being.
    *   *Example:* Ensuring software improves public safety, like emergency alert systems.
2.  Privacy & Data Protection: Safeguard user data and comply with regulations like GDPR.
    *   *Example:* Do not share or sell user data without explicit consent.
3.  Transparency & Accountability: Be honest about software capabilities, limitations, and potential risks.
    *   *Example:* Clearly informing users of the limitations of AI-driven recommendations.
4.  Professional Competence: Continuously improve skills to ensure high-quality, ethical solutions.
    *   *Example:* Regular training in secure coding practices.
5.  Avoiding Harm and Conflicts of Interest: Minimize risk of harm and avoid conflicts.
    *   *Example:* Refraining from introducing vulnerabilities to benefit competing organizations.

*Key Takeaway:* Adhering to ethical codes is crucial for responsible and trustworthy software development.

**Slides 16-17: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Software Ethics
*   Kinds of Software Requirements (Functional & Non-Functional)
*   Additional Types of Software Requirements
*   User & Customer Perspectives on Requirements
*   Common Requirement Issues

**Slides 18-20: Types of Software Requirements**

This section revisits functional, non-functional, and domain requirements, then introduces two new types:

*   **Inverse Requirements:** Describe what the system *should not* do.
*   **Design and Implementation Constraints:** Limitations on how the system can be designed and implemented.

*Key Vocabulary:*

*   **Inverse Requirement:** A requirement that specifies what the system should *not* do.
*   **Design Constraint:** A limitation on the design of the system.
*   **Implementation Constraint:** A limitation on how the system is implemented.

*Analogy:* When building a house, inverse requirements might be "the house should not be built on a floodplain," and design constraints might be "the house must adhere to local zoning regulations."

*Key Takeaway:* A comprehensive set of requirements includes not only what the system should do, but also what it should *not* do and any constraints on its design and implementation.

**Slides 21-22: Types of Software Requirements**

This section revisits functional, non-functional, and domain requirements, then introduces two new types:

*   **Inverse Requirements:** Describe what the system *should not* do.
*   **Design and Implementation Constraints:** Limitations on how the system can be designed and implemented.

*Key Vocabulary:*

*   **Inverse Requirement:** A requirement that specifies what the system should *not* do.
*   **Design Constraint:** A limitation on the design of the system.
*   **Implementation Constraint:** A limitation on how the system is implemented.

*Analogy:* When building a house, inverse requirements might be "the house should not be built on a floodplain," and design constraints might be "the house must adhere to local zoning regulations."

*Key Takeaway:* A comprehensive set of requirements includes not only what the system should do, but also what it should *not* do and any constraints on its design and implementation.

**Slides 23-24: Functional Requirements - 1**

Functional requirements describe what the system does.

*Key Takeaway:* Functional requirements describe the functionality of the system and the services it should provide.

**Slides 25-26: Functional Requirements - 2**

Functional requirements should be complete and consistent.

*Key Takeaway:* Functional requirements should be complete and consistent to minimize misinterpretations and assumptions.

**Slides 27-33: Functional Requirements Example # 1-4**

These slides provides examples of functional requirements.

*Key Takeaway:* Functional requirements should be specific and unambiguous to minimize misinterpretations and assumptions.

**Slides 34-36: Comments on Examples**

Incomplete and ambiguous requirements are open to multiple interpretations and assumptions.

*Key Takeaway:* Incomplete and ambiguous requirements are open to multiple interpretations and assumptions that can lead to poor quality or faulty software.

**Slides 37-39: Types of Software Requirements**

This section revisits functional, non-functional, and domain requirements, then introduces two new types:

*   **Inverse Requirements:** Describe what the system *should not* do.
*   **Design and Implementation Constraints:** Limitations on how the system can be designed and implemented.

*Key Vocabulary:*

*   **Inverse Requirement:** A requirement that specifies what the system should *not* do.
*   **Design Constraint:** A limitation on the design of the system.
*   **Implementation Constraint:** A limitation on how the system is implemented.

*Analogy:* When building a house, inverse requirements might be "the house should not be built on a floodplain," and design constraints might be "the house must adhere to local zoning regulations."

*Key Takeaway:* A comprehensive set of requirements includes not only what the system should do, but also what it should *not* do and any constraints on its design and implementation.

**Practice Quiz Questions:**

1.  Explain the importance of software ethics and provide two examples of ethical considerations in software development.
2.  Describe the ACM/IEEE Code of Ethics principle of "Transparency and Accountability" and provide an example of its application.
3.  What are inverse requirements? Give an example.
4.  What are design and implementation constraints? Give an example.
5.  Why are ambiguous requirements problematic?

**Solutions to Practice Quiz Questions:**

1.  Software ethics is important because it ensures that software is developed responsibly and does not cause harm to individuals or society. Examples of ethical considerations include:
    *   Protecting user privacy by implementing strong data security measures.
    *   Avoiding bias in algorithms to ensure fairness and prevent discrimination.
2.  The ACM/IEEE Code of Ethics principle of "Transparency and Accountability" emphasizes the importance of being honest about a software's capabilities, limitations, and potential risks. An example of its application is clearly informing users about the limitations of AI-driven recommendations, such as the possibility of inaccurate or biased suggestions.
3.  Inverse requirements specify what the system should *not* do. An example is, "The system shall not allow users to delete data from the database directly; all data deletion must go through an audit log."
4.  Design and implementation constraints are limitations on how the system can be designed and implemented. An example is, "The system must be implemented using the Python programming language" (implementation constraint) or "The user interface must conform to the company's established design guidelines" (design constraint).
5.  Ambiguous requirements are problematic because they are open to multiple interpretations and assumptions. This can lead to misunderstandings between stakeholders and developers, resulting in the development of poor-quality or faulty software products that do not meet the intended needs.



## Software Requirement Engineering: Lecture 5 Breakdown

**Introduction**

This lecture delves deeper into the various types of software requirements, emphasizing non-functional and domain requirements. It also explores the different perspectives of users and customers on requirements and addresses common issues in requirements engineering.

**Slides 1-2: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Types of Software Requirements
*   Software Ethics
*   Additional Types of Software Requirements
*   User & Customer Perspectives on Requirements
*   Common Requirement Issues

**Slides 3-7: Types of Software Requirements (Revisited)**

This section revisits the different types of software requirements already discussed:

*   Functional Requirements
*   Non-Functional Requirements
*   Domain Requirements
*   Inverse Requirements
*   Design and Implementation Constraints

*Key Takeaway:* A comprehensive understanding of these different types of requirements is crucial for successful software development.

**Slides 8-11: Non-Functional Requirements - 1 & 2**

Non-functional requirements relate to the system as a whole and include constraints on:

*   Timing
*   Performance
*   Reliability
*   Security
*   Maintainability
*   Accuracy
*   Development process and Standards, etc.

These requirements are often more critical than individual functional requirements and capture the emergent behavior of the system.

*Analogy:* If functional requirements are like the individual instruments in an orchestra, non-functional requirements are like the conductor, ensuring that all the instruments play together in harmony to create a beautiful and coherent sound.

*Key Takeaway:* Non-functional requirements are crucial for ensuring the overall quality and usability of the system.

**Slides 12-14: Non-Functional Requirements (cont..)**

Failure to meet a non-functional system requirement may make the whole system unusable. Non-functional requirements arise through user needs, budget constraints, organizational policies, interoperability needs, or external factors like safety regulations and privacy legislation.

*Analogy:* If the functional requirements are the ingredients of a cake, then the non-functional requirements are about the quality of those ingredients, the oven temperature, and the baking time. If any of these are off, the cake will be a disaster, no matter how good the ingredients are.

*Key Takeaway:* Non-functional requirements are critical for the success of the entire system.

**Slides 15-17: Non-Functional Requirements (cont..)**

Non-functional requirements are further categorized into:

*   Product Requirements
*   Organizational Requirements
*   External Requirements

*Key Takeaway:* Understanding these categories helps in classifying and managing non-functional requirements effectively.

**Slides 18-20: Product Requirements Examples**

The system shall allow one hundred thousand hits per minute on the website. The system shall not have downtime of more than one second for continuous execution of one thousand hours.

*Key Takeaway:* Product requirements define how the product should perform and its characteristics.

**Slide 21: Product Requirements**

Product requirements are further classified into:

*   Efficiency Requirements
*   Reliability Requirements
*   Portability Requirements
*   Usability Requirements
*   Performance Requirements
*   Space Requirements

*Key Takeaway:* Product requirements define the characteristics and qualities of the software product.

**Slides 22-24: Organizational Requirements**

*   Implementation Requirements
*   Standards Requirements
*   Organizational Requirements
*   Delivery Requirements

*Key Takeaway:* Organizational requirements address the standards, processes, and constraints within the development organization.

**Slides 25-26: Organizational Requirements Examples**

The system development process and deliverable documents shall conform to the ISO 9000. Any development work sub-contracted shall be carried out in accordance with Capability Maturity Model (CMM).

*Key Takeaway:* Organizational requirements ensure adherence to standards and best practices.

**Slides 27-29: External Requirements**

*   Ethical Requirements
*   Interoperability Requirements
*   External Requirements
*   Legislative Requirements
*   Privacy Requirements
*   Safety Requirements

*Key Takeaway:* External requirements address factors outside the organization that affect the system.

**Slides 30-31: External Requirements Examples**

The system shall not disclose any personal information about members of the library system to other members except system administrators. The system shall comply with the local and national laws regarding the use of software tools.

*Key Takeaway:* External requirements ensure compliance with laws, regulations, and ethical standards.

**Slides 32-34: Observations on Non-Functional Requirements (1/4)**

Non-functional requirements can be written to reflect general goals for the system, such as ease of use, recovery from failure, and rapid user response.

*Key Takeaway:* Non-functional requirements can be expressed as general goals, but this can lead to misinterpretations.

**Slides 35-37: Observations on Non-Functional Requirements (2/4)**

Goals are open to misinterpretation. Objective verification is difficult. The distinction between functional and non-functional is not always very clear.

*Key Takeaway:* Non-functional requirements should be written in a quantitative manner as much as possible.

**Slides 38-40: Observations on Non-Functional Requirements (3/4)**

Goals can be useful to designers and developers, as they give clues to them about priorities of the customers.

*Key Takeaway:* Goals can be useful to designers and developers, as they give clues to them about priorities of the customers.

**Slides 41-42: Observations on Non-Functional Requirements (4/4)**

Some negotiations must be done among different stakeholders to achieve an agreement in these situations. Non-functional requirements should be highlighted in the requirements document so that they can be used to build the architecture of the software product.

*Key Takeaway:* Non-functional requirements should be highlighted in the requirements document so that they can be used to build the architecture of the software product

**Slides 43-44: NFRs as Goals**

Non-functional requirements are sometimes written as general goals, which are difficult to verify.

*Key Takeaway:* They should be expressed quantitatively using metrics (measures) that can be objectively tested.

**Slides 45-46: Example: Goal converted into an NFR**

Goal (unverifiable): “The system should be easy to use by experienced controllers and should be organized in such a way that user errors are minimized.” Non-functional requirement (verifiable): “Experienced controllers shall be able to use all the system functions after a total of two hours’ training. After this training, the average number of errors made by experienced users shall not exceed two per day.”

*Key Takeaway:* This illustrates the importance of converting general goals into specific, measurable non-functional requirements.

**Slides 47-52: Metrics for Non-Functional Requirements (NFRs)**

These slides highlight the importance of using metrics to quantify non-functional requirements. Specific metrics will be detailed on the next slides.

*Key Takeaway:* Metrics are essential for objectively verifying non-functional requirements.

**Slide 53: Importance of Metrics used for NFRs**

With the help of measures (metrics), the NFRs can be verified quantitatively. It should also be noted that the cost of quantitatively verifying each NFR may be very high.

*Key Takeaway:* Metrics are essential for objectively verifying non-functional requirements.

**Slide 54: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Software Ethics
*   Kinds of Software Requirements (Functional & Non-Functional)
*   Additional Types of Software Requirements
*   User & Customer Perspectives on Requirements
*   Common Requirement Issues

**Slides 55-57: Types of Software Requirements**

This section revisits functional, non-functional, and domain requirements, then introduces two new types:

*   **Inverse Requirements:** Describe what the system *should not* do.
*   **Design and Implementation Constraints:** Limitations on how the system can be designed and implemented.

*Key Vocabulary:*

*   **Inverse Requirement:** A requirement that specifies what the system should *not* do.
*   **Design Constraint:** A limitation on the design of the system.
*   **Implementation Constraint:** A limitation on how the system is implemented.

*Analogy:* When building a house, inverse requirements might be "the house should not be built on a floodplain," and design constraints might be "the house must adhere to local zoning regulations."

*Key Takeaway:* A comprehensive set of requirements includes not only what the system should do, but also what it should *not* do and any constraints on its design and implementation.

**Slides 58-61: Domain Requirements - 1, 2, 3, 4**

Domain requirements come from the application domain and reflect fundamental characteristics of that domain. These can be both functional or non-functional requirements.

*Analogy:* Domain requirements are similar to the rules of the road for a self-driving car. They are specific to the domain of driving and must be followed to ensure safety and compliance.

*Key Takeaway:* Domain requirements are crucial for ensuring that the system is appropriate for its intended application.

**Slides 62-64: Types of Software Requirements**

This section revisits functional, non-functional, and domain requirements, then introduces two new types:

*   **Inverse Requirements:** Describe what the system *should not* do.
*   **Design and Implementation Constraints:** Limitations on how the system can be designed and implemented.

*Key Vocabulary:*

*   **Inverse Requirement:** A requirement that specifies what the system should *not* do.
*   **Design Constraint:** A limitation on the design of the system.
*   **Implementation Constraint:** A limitation on how the system is implemented.

*Analogy:* When building a house, inverse requirements might be "the house should not be built on a floodplain," and design constraints might be "the house must adhere to local zoning regulations."

*Key Takeaway:* A comprehensive set of requirements includes not only what the system should do, but also what it should *not* do and any constraints on its design and implementation.

**Slides 65-67: Inverse Requirements - 1, 2**

They explain what the system shall not do. Many people find it convenient to describe their needs in this manner.

*Analogy:* Inverse requirements are like the "do not" signs on a hiking trail. They tell you what you should not do to protect the environment and yourself.

*Key Takeaway:* Inverse requirements are important for clarifying the boundaries of the system and preventing unintended behavior.

**Slides 68-70: Types of Software Requirements**

This section revisits functional, non-functional, and domain requirements, then introduces two new types:

*   **Inverse Requirements:** Describe what the system *should not* do.
*   **Design and Implementation Constraints:** Limitations on how the system can be designed and implemented.

*Key Vocabulary:*

*   **Inverse Requirement:** A requirement that specifies what the system should *not* do.
*   **Design Constraint:** A limitation on the design of the system.
*   **Implementation Constraint:** A limitation on how the system is implemented.

*Analogy:* When building a house, inverse requirements might be "the house should not be built on a floodplain," and design constraints might be "the house must adhere to local zoning regulations."

*Key Takeaway:* A comprehensive set of requirements includes not only what the system should do, but also what it should *not* do and any constraints on its design and implementation.

**Slides 71-73: Design and Implementation Constraints - 1**

These are development guidelines within which the designer must work. These requirements can seriously limit design and implementation options.

*Analogy:* Design and implementation constraints are like the building codes that architects and builders must follow. They ensure that the building is safe and meets certain standards.

*Key Takeaway:* Design and implementation constraints are important for ensuring that the system is built in a consistent and maintainable way.

**Slides 74-75: Design and Implementation Constraints - Examples**

The system shall be developed using the Microsoft .Net platform. The system shall be developed using open-source tools and shall run on Linux operating system.

*Key Takeaway:* Design and implementation constraints provide specific guidance for the development team.

**Slides 76-77: Examples 1, 2**

These slides summarize the different types of requirements with examples.

*Key Takeaway:* A clear understanding of each requirement type is essential.

**Slides 78-80: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Software Ethics
*   Kinds of Software Requirements (Functional & Non-Functional)
*   Additional Types of Software Requirements
*   User & Customer Perspectives on Requirements
*   Common Requirement Issues

**Slides 81-83: Understanding Stakeholder Perspectives**

Users prioritize usability, performance, and accessibility, while customers prioritize security, compliance, and cost-effectiveness.

*Analogy:* Think of a restaurant. Users (diners) care about the taste of the food, the speed of service, and the atmosphere. Customers (owners) care about the cost of ingredients, the efficiency of the kitchen, and compliance with health regulations.

*Key Takeaway:* Balancing the needs of users and customers is a key challenge in requirements engineering.

**Slides 84-86: User & Customer Perspectives on Requirements**

Users expect an intuitive and easy-to-use interface, require fast and efficient system performance, and need accessibility features for diverse users. Customers focus on ensuring regulatory compliance, prioritize data security and financial constraints, and require cost-efficient and maintainable solutions.

*Key Takeaway:* Understanding and addressing the different perspectives of users and customers is essential for creating successful software.

**Slides 87-89: Challenges in Meeting Both Perspectives**

Balancing usability with security measures, aligning performance expectations with budget constraints, and ensuring compliance without compromising user experience.

*Key Takeaway:* Meeting the needs of both users and customers often requires trade-offs and compromises.

**Slides 90-92: Solutions for Aligning Perspectives**

Involve both users and customers in requirement gathering, use iterative design processes (e.g., prototyping and user feedback), and implement adaptive security and accessibility features.

*Key Takeaway:* Collaboration, iteration, and adaptive design are key strategies for aligning user and customer perspectives.

**Slide 93: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Software Ethics
*   Kinds of Software Requirements (Functional & Non-Functional)
*   Additional Types of Software Requirements
*   User & Customer Perspectives on Requirements
*   Common Requirement Issues

**Slides 94-96: Common Requirement Issues**

Common Requirement Issues: Already discussed in Lecture 02 Week 01. The main risks of Requirements Engineering: Insufficient user involvement, creeping user requirements, ambiguous requirements, gold plating, inaccurate planning, overlooked user classes.

*Key Takeaway:* Addressing these risks is crucial for successful requirements engineering.

**Slides 97-99: Common Requirement Problems & Solutions**

Best Practices for Contractual and Requirement Management: Clearly define the scope and deliverables in contracts, establish change control mechanisms, ensure stakeholder alignment before project initiation, and conduct regular reviews and updates to requirement documents.

*Key Takeaway:* Effective contractual and requirement management practices are essential for mitigating common requirement problems.

**Slide 100: Why Requirements are Important?**

This slide is a summary of why requirements are important.

*Key Takeaway:* Requirements are the basis for a successful software project because they establish the foundation for what is to be built.

**Practice Quiz Questions:**

1.  What are the three main categories of non-functional requirements? Give an example of each.
2.  Explain why it is important to quantify non-functional requirements. How can this be achieved?
3.  Describe the difference between domain requirements and inverse requirements, providing an example of each.
4.  Explain the differing priorities of users and customers in requirements gathering. Give an example of a potential conflict and how it can be resolved.
5.  List three best practices for managing requirements and preventing common problems.

**Solutions to Practice Quiz Questions:**

1.  The three main categories of non-functional requirements are:
    *   *Product Requirements:* Related to the characteristics of the software product itself. Example: "The system shall have a response time of less than 2 seconds for 90% of user requests."
    *   *Organizational Requirements:* Related to the development organization and its processes. Example: "The development team shall follow the company's coding standards."
    *   *External Requirements:* Related to external factors such as laws, regulations, and ethical considerations. Example: "The system shall comply with GDPR privacy regulations."
2.  It is important to quantify non-functional requirements because it makes them testable and verifiable. This can be achieved by using metrics, which are objective measures that can be used to assess whether the requirement has been met. For example, instead of saying "The system should be fast," you could say "The system shall have a response time of less than 2 seconds."
3.  *Domain requirements* are specific to the application domain and reflect fundamental characteristics of that domain. Example: "A banking system must comply with all applicable financial regulations." *Inverse requirements* specify what the system should *not* do. Example: "The system must not allow unauthorized access to sensitive data."
4.  Users typically prioritize usability, performance, and accessibility, while customers prioritize security, compliance, and cost-effectiveness. A potential conflict could arise if implementing strong security measures (customer priority) makes the system more difficult to use (user priority). This can be resolved by involving both users and customers in the design process and finding a balance between security and usability, such as implementing user-friendly authentication methods.
5.  Three best practices for managing requirements are:
    *   Clearly define the scope and deliverables in contracts.
    *   Establish change control mechanisms to manage changes to requirements.
    *   Ensure stakeholder alignment before project initiation to avoid conflicting requirements.


## Software Requirement Engineering: Lecture 6 Breakdown

**Introduction**

This lecture introduces various process models used in software development, contrasting traditional and agile approaches to requirements engineering. It also covers documenting requirements, measuring quality, and includes an activity and case study to illustrate the concepts.

**Slides 1-2: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Introduction to Process Models
*   Traditional vs. Agile Requirements Engineering
*   Documenting Requirements
*   Quality Measurement in Requirements Engineering
*   Activity & Case Study

**Slides 3-4: Introduction to Process Models**

Process models define structured methodologies for software development, helping in planning, executing, and managing software projects efficiently.

*Analogy:* Think of process models as different recipes for baking a cake. Each recipe (process model) provides a set of steps and guidelines to follow, but they vary in their approach and suitability for different types of cakes (software projects).

*Key Takeaway:* Process models provide a structured framework for software development.

**Slides 5-6: Introduction to Process Models**

Types of Process Models:

*   Waterfall Model
*   V-Model
*   Incremental Model
*   Spiral Model
*   Agile Model

*Key Takeaway:* There are various process models to choose from, each with its strengths and weaknesses.

**Slides 7-8: Introduction to Process Models - Waterfall Model**

The Waterfall Model follows a strict sequence: Requirements → Design → Implementation → Testing → Deployment → Maintenance. It's used in projects with well-defined and fixed requirements.

*Analogy:* The Waterfall Model is like an assembly line where each stage must be completed before moving on to the next.

*Key Takeaway:* The Waterfall Model is suitable for projects with stable requirements.

**Slides 9-10: Introduction to Process Models - Waterfall Model**

Strengths: Easy to manage, clear documentation. Weaknesses: Inflexible, difficult to accommodate changes. Example: Used in large-scale government or defense projects.

*Key Takeaway:* The Waterfall Model is easy to manage but lacks flexibility.

**Slides 11-12: Introduction to Process Models - V-Model**

The V-Model is an extension of the Waterfall model with a focus on testing at every stage. Each phase has a corresponding validation/testing phase.

*Analogy:* The V-Model is like a mirror image of the Waterfall model, with testing phases mirroring the development phases.

*Key Takeaway:* The V-Model emphasizes early defect detection through rigorous testing.

**Slides 13-14: Introduction to Process Models - V-Model**

Strengths: High reliability due to early defect detection. Weaknesses: Expensive and time-consuming. Example: Used in safety-critical systems like medical devices and avionics software.

*Key Takeaway:* The V-Model ensures high reliability but is expensive and time-consuming.

**Slides 15-16: Introduction to Process Models - Incremental Model**

The Incremental Model divides the project into smaller modules, each developed and tested incrementally. Each increment delivers part of the functionality.

*Analogy:* The Incremental Model is like building a house one room at a time, adding functionality with each increment.

*Key Takeaway:* The Incremental Model allows for early feedback and flexibility.

**Slides 17-18: Introduction to Process Models - Incremental Model**

Strengths: Allows early feedback, more flexible than Waterfall. Weaknesses: Requires proper planning to integrate all increments. Example: Used in developing web-based applications with evolving features.

*Key Takeaway:* The Incremental Model is flexible but requires careful planning for integration.

**Slides 19-20: Introduction to Process Models - Spiral Model**

The Spiral Model focuses on iterative risk assessment and mitigation. Each cycle includes Planning, Risk Analysis, Engineering, and Evaluation.

*Analogy:* The Spiral Model is like a continuous loop of planning, building, testing, and evaluating, with a focus on identifying and mitigating risks at each stage.

*Key Takeaway:* The Spiral Model is suitable for large and complex projects with high risks.

**Slides 21-22: Introduction to Process Models - Spiral Model**

Strengths: Handles risks proactively, suitable for large and complex projects. Weaknesses: Expensive, requires expertise in risk management. Example: Used in aerospace and banking systems where risk assessment is crucial.

*Key Takeaway:* The Spiral Model is risk-driven but expensive and requires risk management expertise.

**Slides 23-24: Introduction to Process Models - Agile Model**

The Agile Model encourages iterative development with continuous user feedback. Uses frameworks like Scrum, Kanban, and XP (Extreme Programming).

*Analogy:* The Agile Model is like a team of chefs continuously tasting and adjusting a dish based on customer feedback.

*Key Takeaway:* The Agile Model is flexible and emphasizes collaboration and user feedback.

**Slides 25-26: Introduction to Process Models - Agile Model**

Strengths: Flexible, high user involvement, quick delivery of functional software. Weaknesses: Requires strong collaboration, less suited for projects with strict regulations. Example: Used in startups and evolving software products like mobile applications.

*Key Takeaway:* The Agile Model is flexible and delivers software quickly but requires strong collaboration.

**Slides 27-28: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Introduction to Process Models
*   Traditional vs. Agile Requirements Engineering
*   Documenting Requirements
*   Quality Measurement in Requirements Engineering
*   Activity & Case Study

**Slides 29-30: Traditional vs. Agile Requirements Engineering**

Requirements engineering involves gathering, documenting, and managing system requirements. Two primary approaches exist: Traditional (Waterfall) and Agile (Scrum etc.).

*Analogy:* Traditional requirements engineering is like creating a detailed blueprint before building a house, while agile requirements engineering is like sketching a rough plan and adjusting it as you build.

*Key Takeaway:* The choice between traditional and agile approaches depends on the project's requirements and constraints.

**Slides 31-32: Traditional Requirements Engineering**

Characteristics: Follows a structured, sequential approach, detailed upfront documentation, requirements are fixed early, and minimal flexibility.

*Key Takeaway:* Traditional requirements engineering emphasizes upfront planning and documentation.

**Slides 33-34: Traditional Requirements Engineering**

Strengths: Well-suited for projects with clearly defined requirements, strong documentation and compliance support, predictable timeline and budget. Weaknesses: High risk of requirement changes being costly, late-stage feedback leads to expensive fixes, inflexible when requirements evolve.

*Key Takeaway:* Traditional requirements engineering is predictable but inflexible.

**Slides 35-36: Traditional Requirements Engineering**

Example: Used in government and large-scale enterprise systems where regulations require fixed documentation and predictability.

*Key Takeaway:* Traditional requirements engineering is suitable for projects with strict regulatory requirements.

**Slides 37-38: Agile Requirements Engineering**

Characteristics: Iterative and incremental development, requirements evolve based on continuous feedback, emphasizes working software over detailed documentation, and collaboration is crucial.

*Key Takeaway:* Agile requirements engineering emphasizes flexibility and collaboration.

**Slides 39-40: Agile Requirements Engineering**

Strengths: Adaptable to changing requirements and customer feedback, reduces risk by validating requirements through iterative development, delivers functional software quickly. Weaknesses: Requires close collaboration, can be difficult to maintain documentation consistency, not ideal for projects with strict regulatory requirements.

*Key Takeaway:* Agile requirements engineering is adaptable but requires strong collaboration.

**Slides 41-42: Agile Requirements Engineering**

Example: Startups and dynamic industries benefit from Agile due to evolving requirements and rapid iterations.

*Key Takeaway:* Agile requirements engineering is suitable for projects with evolving requirements.

**Slide 43: Comparison Table!**

This slide provides a comparison between agile vs. traditional requirements engineering.

*Key Takeaway:* A clear understanding of each requirement type is essential.

**Slides 44-45: Hybrid Approach: Best of Both Worlds**

Some projects use a Hybrid Model, integrating structured documentation from traditional methods with Agile’s adaptability.

*Analogy:* A hybrid approach is like building a house with a solid foundation (traditional) but using flexible interior design (agile).

*Key Takeaway:* A hybrid approach can combine the strengths of both traditional and agile methods.

**Slides 46-47: Case Study**

Agile vs. Waterfall in a Real-World Project: A banking company initially followed the Waterfall model to develop an online banking system. Challenges arose when unexpected regulatory changes required modifications. Switching to Agile for mobile banking allowed incremental changes and rapid adaptation.

*Key Takeaway:* This case study illustrates the benefits of Agile in dynamic environments.

**Slides 48-50: Case Study (1, 2)**

Analysis & Lessons Learned: Impact of Switching from Waterfall to Agile

*Key Takeaway:* The case study shows the benefits of switching from Waterfall to Agile.

**Slides 51-53: Case Study (3)**

Before the Switch (Waterfall Challenges): Regulatory changes caused major delays, late-stage modifications were expensive, and limited stakeholder involvement resulted in features that didn’t fully align with user needs.

*Key Takeaway:* The case study shows the challenges of using Waterfall in a dynamic environment.

**Slides 54-56: Case Study (4)**

After the Switch (Agile Benefits): Iterative development allowed faster adaptation, continuous feedback helped refine the mobile banking app, and shorter release cycles meant features were tested and deployed incrementally.

*Key Takeaway:* The case study shows the benefits of switching to Agile in a dynamic environment.

**Slide 57: Key Metrics for Success Evaluation (5)**

This slide lists key metrics for success evaluation.

*Key Takeaway:* Metrics are essential for objectively verifying non-functional requirements.

**Slide 58: Lessons Learned (6)**

Agile works best for evolving regulatory environments, allowing frequent updates. Waterfall is useful for initial large-scale system documentation but lacks flexibility.

*Key Takeaway:* Agile is better for evolving regulatory environments, while Waterfall is useful for initial large-scale system documentation but lacks flexibility.

**Slide 59: Final Outcome & Future Recommendations (7)**

The online banking system (built in Waterfall) serves as a stable, core backend. The mobile banking system (built in Agile) evolves continuously based on market needs. Future projects should evaluate complexity & regulatory risks before choosing a model.

*Key Takeaway:* The choice of process model should be based on the project's complexity and regulatory risks.

**Slide 60: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Introduction to Process Models
*   Traditional vs. Agile Requirements Engineering
*   Documenting Requirements
*   Quality Measurement in Requirements Engineering
*   Activity & Case Study

**Practice Quiz Questions:**

1.  Describe the key differences between the Waterfall and Agile process models. In what types of projects is each model most suitable?
2.  What are the strengths and weaknesses of traditional requirements engineering?
3.  What are the strengths and weaknesses of agile requirements engineering?
4.  What is a hybrid approach to requirements engineering, and why might it be beneficial?
5.  In the case study presented, why did the banking company switch from Waterfall to Agile for its mobile banking app? What lessons were learned?

**Solutions to Practice Quiz Questions:**

1.  *Waterfall* is a linear, sequential model with fixed requirements, suitable for projects with well-defined, stable requirements. *Agile* is an iterative, collaborative model with evolving requirements, suitable for projects with changing needs and a need for rapid feedback.
2.  *Strengths of Traditional RE:* Well-suited for projects with clearly defined requirements, strong documentation, predictable timeline and budget. *Weaknesses:* Inflexible, costly to change requirements, late-stage feedback.
3.  *Strengths of Agile RE:* Adaptable to changing requirements, iterative development, delivers functional software quickly. *Weaknesses:* Requires close collaboration, difficult to maintain documentation consistency, not ideal for strict regulatory requirements.
4.  A *hybrid approach* combines elements of both traditional and agile methods, such as using structured documentation upfront (traditional) and iterative development sprints (agile). It can be beneficial for large enterprises that need to balance compliance with the need for flexibility.
5.  The banking company switched to Agile for its mobile banking app because regulatory changes required frequent updates, and the mobile app needed to evolve based on customer feedback. Lessons learned included that Agile is best for evolving environments, while Waterfall is useful for initial documentation, and a hybrid approach can balance both.

## Software Requirement Engineering: Lecture 7 Breakdown

**Introduction**

This lecture focuses on the importance of documenting software requirements, the different types of documentation, and the characteristics of a good Software Requirements Specification (SRS). It also covers use case diagrams and user stories.

**Slides 1-2: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Introduction to Process Models
*   Traditional vs. Agile Requirements Engineering
*   Documenting Requirements
*   Quality Measurement in Requirements Engineering
*   Activity & Case Study

**Slides 3-4: What is Documenting?**

Documentation refers to the structured recording of information about a software project. It helps developers, testers, and stakeholders understand project requirements and functionality, and provides a reference for future modifications and maintenance.

*Analogy:* Documentation is like a detailed instruction manual for a complex machine. It explains how the machine works, how to operate it, and how to troubleshoot problems.

*Key Takeaway:* Documentation provides a structured record of project information for understanding, maintenance, and future modifications.

**Slides 5-6: Software Documentation**

Software Documentation: It is a written piece of text that is often accompanied by a software program. This makes the life of all the members associated with the project easier. It may contain anything from API documentation, build notes, or just help content.

*Key Takeaway:* Software documentation supports all project members by providing essential information.

**Slides 7-10: Types of Software Documentation**

*   **Requirement Documentation:** Description of how the software shall perform and the appropriate environment setup.
*   **Architectural Documentation:** Concerns the design, components of the system, their roles, and data flow.
*   **Technical Documentation:** Contains technical aspects like APIs and algorithms, primarily for developers.
*   **End-user Documentation:** Support resources for the end user, such as user manuals.

*Analogy:* Imagine building a house. Requirement documentation is like the architectural blueprints, architectural documentation is like the structural engineering plans, technical documentation is like the electrician's wiring diagrams, and end-user documentation is like the homeowner's manual.

*Key Takeaway:* Different types of documentation cater to different audiences and purposes.

**Slide 11: Why is Documentation Important?**

*   Ensures clarity and consistency in requirements.
*   Reduces ambiguity and misinterpretation.
*   Supports regulatory and compliance needs.
*   Facilitates communication among stakeholders.
*   Improves project traceability and management.

*Key Takeaway:* Documentation is essential for clarity, compliance, communication, and project management.

**Slide 12: Types of Requirement Documents**

*   Software Requirements Specification (SRS)
*   Use Case Diagrams & User Stories
*   Functional & Non-Functional Requirements
*   Traceability Matrix

*Key Takeaway:* Various types of documents capture and manage requirements.

**Slides 13-14: Software Requirements Specification (SRS)**

A Software Requirements Specification (SRS) is a detailed document that describes the system functionality, constraints, and technical specifications. It serves as a contract between stakeholders and developers, ensuring that the final product meets business and user expectations. Typically follows industry standards like IEEE 830.

*Analogy:* The SRS is like a legally binding contract between a client and a construction company, outlining exactly what will be built and how.

*Key Takeaway:* The SRS is a comprehensive document that serves as a contract between stakeholders and developers.

**Slide 15: Why is SRS Important?**

*   Provides clear documentation of system requirements, reducing miscommunication.
*   Serves as a reference for development, testing, and maintenance.
*   Ensures compliance with regulatory and security standards.
*   Facilitates project planning and risk management.

*Key Takeaway:* The SRS is crucial for communication, compliance, and project management.

**Slide 16: Characteristics of a Good SRS**

*   Complete: Covers all aspects of the system.
*   Consistent: No conflicting requirements.
*   Unambiguous: Clearly defined, leaving no room for misinterpretation.
*   Verifiable: Can be tested to ensure compliance.
*   Feasible: Realistic within the constraints of budget, time, and technology.

*Key Takeaway:* A good SRS is complete, consistent, unambiguous, verifiable, and feasible.

**Slide 17: Pros & Cons of SRS**

This slide is not included in the extracted text.

*Key Takeaway:* N/A

**Slides 18-20: Structure of an SRS Document (1/2)**

*   Introduction: Purpose, scope, definitions.
*   Overall Description: System environment, constraints, assumptions.
*   Functional Requirements: Detailed system functionalities.

*Key Takeaway:* The SRS has a well-defined structure to organize requirements.

**Slides 21-22: Structure of an SRS Document (2/2)**

*   Non-Functional Requirements: Performance, security, usability, and reliability constraints.
*   External Interface Requirements: User, hardware, and communication interfaces.
*   System Models: Diagrams, use cases, and data flow models.

*Key Takeaway:* The SRS has a well-defined structure to organize requirements.

**Slides 23-25: Real-Life Example: SRS for an Online Banking System (1)**

Introduction:
*   Purpose: To design an online banking system that allows secure financial transactions.
*   Scope: Users can check balances, transfer funds, and manage accounts.
*   Acronyms & Abbreviations: PCI-DSS, MFA.

*Key Takeaway:* The introduction sets the context for the system.

**Slides 26-27: SRS for an Online Banking System (2)**

Overall Description:
*   System Constraints: The system must comply with PCI-DSS security standards.
*   Assumptions: Users will have stable internet connections.

*Key Takeaway:* The overall description outlines constraints and assumptions.

**Slides 28-29: SRS for an Online Banking System (3)**

Functional Requirements:
*   Users must log in using two-factor authentication (MFA).
*   The system must allow fund transfers between accounts.
*   Users can check account balances and download transaction history.
*   Admins must be able to generate account statements.

*Key Takeaway:* Functional requirements detail what the system should do.

**Slides 30-31: SRS for an Online Banking System (4)**

Non-Functional Requirements:
*   Transactions should process within 2 seconds.
*   The system must comply with PCI-DSS security standards.
*   The UI should be accessible for users with disabilities.
*   System uptime must be 99.9%.

*Key Takeaway:* Non-functional requirements specify how the system should perform.

**Slides 32-33: SRS for an Online Banking System (5)**

External Interface Requirements:
*   User Interfaces: Web-based dashboard and mobile app.
*   Hardware Interfaces: The system should be compatible with fingerprint authentication on mobile devices.
*   Communication Interfaces: Secure API integrations for third-party payment processing.

*Key Takeaway:* External interface requirements define how the system interacts with other systems and users.

**Slides 34-35: SRS for an Online Banking System (6)**

System Models:
*   Use Case Diagrams: Account login and verification, fund transfer authorization.
*   Sequence Diagrams: User authentication flow, transaction approval process.

*Key Takeaway:* System models provide visual representations of system behavior.

**Slides 36-38: Use Case Diagrams & User Stories**

2.1. Use Case Diagrams: A graphical representation of user interactions with a system, showing actors and their interactions with system functionalities.

*Analogy:* A use case diagram is like a map of a theme park, showing the different attractions (use cases) and the types of visitors (actors) who can access them.

*Key Takeaway:* Use case diagrams visualize user-system interactions.

**Slide 39: Components of a Use Case Diagram**

*   Actors: Represent users or external systems.
*   Use Cases: Specific actions or functionalities.
*   Relationships: Indicate how actors interact with use cases.
*   System Boundary: Defines the limits of the system.

*Key Takeaway:* Understanding these components is key to creating effective use case diagrams.

**Slide 40: Use Case Diagram**

This slide provides a visual example of a use case diagram.

*Key Takeaway:* Use case diagrams provide a clear visual representation of system functionality.

**Slides 41-43: 2.2. User Stories**

A simple, informal way to capture system functionalities from the user's perspective. Commonly used in Agile development.

*Analogy:* User stories are like short notes from a customer to a chef, requesting specific dishes with particular preferences.

*Key Takeaway:* User stories capture requirements from the user's perspective.

**Slide 44: Structure of a User Story**

Format: "As a [user role], I want to [feature] so that [benefit]." Example: "As a customer, I want to reset my password so that I can regain account access."

*Key Takeaway:* User stories follow a simple, structured format.

**Practice Quiz Questions:**

1.  What are the four main types of software documentation, and what is the purpose of each?
2.  What is a Software Requirements Specification (SRS), and why is it important?
3.  List and describe five characteristics of a good SRS.
4.  Describe the main components of a use case diagram.
5.  What is a user story, and what is its structure? Provide an example.

**Solutions to Practice Quiz Questions:**

1.  *Requirement Documentation:* Describes how the software shall perform and the appropriate environment setup. *Architectural Documentation:* Concerns the design, components of the system, their roles, and data flow. *Technical Documentation:* Contains technical aspects like APIs and algorithms, primarily for developers. *End-user Documentation:* Support resources for the end user, such as user manuals.
2.  An SRS is a detailed document that describes the system's functionality, constraints, and technical specifications. It is important because it serves as a contract between stakeholders and developers, ensuring that the final product meets business and user expectations.
3.  Five characteristics of a good SRS:
    *   *Complete:* Covers all aspects of the system.
    *   *Consistent:* No conflicting requirements.
    *   *Unambiguous:* Clearly defined, leaving no room for misinterpretation.
    *   *Verifiable:* Can be tested to ensure compliance.
    *   *Feasible:* Realistic within the constraints of budget, time, and technology.
4.  The main components of a use case diagram are:
    *   *Actors:* Represent users or external systems.
    *   *Use Cases:* Specific actions or functionalities.
    *   *Relationships:* Indicate how actors interact with use cases.
    *   *System Boundary:* Defines the limits of the system.
5.  A user story is a simple, informal way to capture system functionalities from the user's perspective. Its structure is: "As a [user role], I want to [feature] so that [benefit]." Example: "As a user, I want to search for products so that I can find what I need quickly."

## Software Requirement Engineering: Lecture 8 Breakdown

**Introduction**

This lecture builds on the previous one by diving deeper into user stories, functional and non-functional requirements, and traceability matrices. It also provides guidelines for writing effective requirements.

**Slides 1-2: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Introduction to Process Models
*   Traditional vs. Agile Requirements Engineering
*   Documenting Requirements
*   Quality Measurement in Requirements Engineering
*   Activity & Case Study

**Slides 3-4: 2.2. User Stories**

A simple, informal way to capture system functionalities from the user's perspective. Commonly used in Agile development to describe features concisely.

*Analogy:* User stories are like short, customer-focused descriptions of what a software system should do, written from the perspective of the end-user.

*Key Takeaway:* User stories are a key tool in Agile for capturing user needs.

**Slide 5: Structure of a User Story**

Format: "As a [user role], I want to [feature] so that [benefit]." Example: "As a customer, I want to reset my password so that I can regain account access."

*Key Takeaway:* User stories follow a simple, structured format.

**Slide 6: Characteristics of Good User Stories (INVEST Model)**

*   Independent: Should be self-contained and not dependent on others.
*   Negotiable: Can be refined based on team discussions.
*   Valuable: Provides value to the user.
*   Estimable: Can be estimated in terms of effort required.
*   Small: Should be completed within one development iteration.
*   Testable: Can be validated through acceptance criteria.

*Key Takeaway:* The INVEST model provides a checklist for creating effective user stories.

**Slides 7-8: Example of User Story for an Online Banking System (1/2)**

Title: Fund Transfer Between Accounts
Description: "As a user, I want to transfer money between my accounts so that I can manage my finances efficiently."
Acceptance Criteria:
*   User can select source and destination accounts.
*   User can enter the transfer amount.
*   System verifies available balance before proceeding.
*   Transaction confirmation message is displayed.

*Key Takeaway:* This example illustrates a well-written user story with clear acceptance criteria.

**Slide 9: Example of User Story for an Online Banking System (2/2)**

Use Case Diagrams: Graphical representation of user interactions with the system.
User Stories: Simple descriptions of a feature from an end-user perspective, used in Agile projects.

*Key Takeaway:* This slide highlights the difference between user stories and use case diagrams.

**Slides 10-11: Functional & Non-Functional Requirements (1/2)**

*   Functional Requirements: “Define what the system must do”
    *   Example: "The system shall allow users to log in using a username & password."
*   Non-Functional Requirements: “Define system quality attributes such as performance, security, and usability”
    *   Example: "The system must handle 1000 concurrent users with <2s response time."

*Key Takeaway:* This slide reinforces the key differences between functional and non-functional requirements.

**Slide 12: Functional & Non-Functional Requirements (2/2)**

Real-Life Example:
Online Shopping Website:
Functional requirements include product search, checkout, and order tracking, while Non-functional requirements cover security, speed, and reliability.

*Key Takeaway:* This example illustrates functional and non-functional requirements in a real-world context.

**Slides 13-14: Viewpoints of Requirement Documentations (1/3)**

SRS (Software Requirements Specification) is a comprehensive document that includes various elements like Functional & Non-Functional Requirements, Use Cases, and System Models.

*Key Takeaway:* The SRS can be structured in different ways, depending on the project methodology.

**Slides 15-16: Viewpoints of Requirement Documentations (2/3)**

Types of Requirement Documents can be viewed in two ways:
*   Independent Documents: Agile projects may maintain Use Cases, User Stories, Functional & Non-Functional Requirements, and Traceability Matrices as separate lightweight documents.
*   Structured SRS Approach: Traditional or regulated environments may combine all these elements within the SRS as different sections.

*Key Takeaway:* Documentation approach depends on the project's methodology and regulatory environment.

**Slides 17-18: Viewpoints of Requirement Documentations (3/3)**

SRS is a high-level document that integrates multiple requirement elements.

*Key Takeaway:* The SRS can integrate multiple requirement elements and provide a comprehensive view.

**Slides 19-21: Regression Testing (1/3)**

Regression testing is a software testing technique that ensures that a program works as expected after changes to the code.

*Analogy:* Regression testing is like re-running all the tests on a car after making a repair, to ensure that the repair didn't create any new problems.

*Key Takeaway:* Regression testing is crucial for maintaining software quality after changes.

**Slides 22-24: Regression Testing (2/3)**

Every QA team needs to understand a client’s requirements and ensure to launch a defect-free application into the market.

*Key Takeaway:* The QA team needs to understand requirements and draft the test plan covering all the functionalities/requirements.

**Slides 25-27: Regression Testing (3/3)**

A simple & easy solution is to map the requirement with related test scenarios and respective test cases. This map can be called a ‘Requirement Traceability Matrix (RTM)’.

*Key Takeaway:* A Requirement Traceability Matrix (RTM) is used to ensure that all possible scenarios/cases are covered in the test plan.

**Slides 28-30: Traceability Matrix (1/3)**

A Requirement Traceability Matrix (RTM), also known as Traceability Matrix, is a document that maps and tracks the relationship between requirements, design, implementation, and testing.

*Analogy:* The RTM is like a roadmap that connects every requirement to its corresponding design elements, code implementation, and test cases, ensuring that nothing is missed.

*Key Takeaway:* The RTM ensures that every requirement is properly implemented and validated.

**Slides 31-33: Traceability Matrix (2/3)**

RTM maps all the requirements with the test cases. By using RTM (document), one can verify test cases cover all functionality of the application as per the requirements of the customer.

*Key Takeaway:* RTM helps verify test cases cover all functionality of the application as per the requirements of the customer.

**Slides 34-36: Traceability Matrix (3/3)**

The main purpose of the requirement traceability matrix is to verify that all requirements of clients are covered in the test cases designed by the testers.

*Key Takeaway:* RTM helps verify that all requirements of clients are covered in the test cases designed by the testers.

**Slide 37: Why is a Traceability Matrix Important?**

*   Helps in requirement verification by ensuring all requirements are covered.
*   Assists in impact analysis when making changes to the system.
*   Useful for audits and compliance tracking (e.g., HIPAA, GDPR, ISO standards).
*   Reduces risk by preventing missing or untested requirements.

*Key Takeaway:* An RTM is crucial for verification, impact analysis, compliance, and risk reduction.

**Slide 38: Parameters of RTM**

*   Requirement ID: The requirement ID is assigned to every requirement of the project.
*   Requirement description: For every requirement, a detailed description is given in the SRS (System/Software Requirement Specification) document.
*   Requirement Type: Understand the type of requirements, i.e., banking, telecom, healthcare, traveling, e-commerce, education, etc.
*   Test cases ID: The testing team designs test cases. Test cases are also assigned with some ID.

*Key Takeaway:* An RTM has parameters for better understanding of the requirements.

**Slide 39: Types of Traceability Matrices**

*   Forward Traceability – Ensures that all requirements are implemented in the final product.
*   Backward Traceability – Ensures that all design and development work is based on original requirements.
*   Bidirectional Traceability – Links requirements to test cases, ensuring full coverage both ways.

*Key Takeaway:* Different types of traceability matrices serve different purposes.

**Slide 40: Forward Traceability**

In the forward traceability matrix, requirements are mapped with the test cases.

*Key Takeaway:* Forward traceability ensures that all requirements are covered in test cases.

**Slide 41: Backward Traceability**

In the backward traceability matrix, test cases are mapped with the requirements.

*Key Takeaway:* Backward traceability ensures that no extra test case is added which is not required as per our requirements.

**Slide 42: Bidirectional Traceability**

A bi-directional traceability matrix is a combination of a forward traceability matrix and a backward traceability matrix.

*Key Takeaway:* Bidirectional traceability ensures full coverage both ways.

**Slide 43: Structure of a Traceability Matrix**

This slide shows how to design the structure of a traceability matrix.

*Key Takeaway:* A clear structure to the traceability matrix will be helpful for understanding and managing the requirements.

**Slide 44: Example-1: Traceability Matrix for an Online Banking System**

This slide shows an example of a traceability matrix for online banking system.

*Key Takeaway:* Understanding through example is a good way to comprehend the traceability matrix.

**Slides 45-46: Example-2: Traceability Matrix in a Healthcare System**

Provides an audit trail for external regulatory inspections. Outcome: The traceability matrix helps verify that each HIPAA requirement is properly implemented and tested before deployment.

*Key Takeaway:* This example illustrates the importance of traceability matrices in regulated industries.

**Slide 47: Benefits of Using a Traceability Matrix**

This slide summarizes the benefits of using a traceability matrix.

*Key Takeaway:* RTM helps verify that all requirements of clients are covered in the test cases designed by the testers.

**Slides 48-49: Challenges & Best Practices**

Challenge: Keeping the matrix updated in fast-paced projects. Solution: Automate traceability tracking using requirement management tools (e.g., JIRA, IBM DOORS).

*Key Takeaway:* Managing and maintaining a traceability matrix can be challenging, but automation can help.

**Slide 50: Final One (RTM)**

The Traceability Matrix is a critical tool in software development for requirement validation and compliance.

*Key Takeaway:* The Traceability Matrix is a critical tool in software development for requirement validation and compliance.

**Slide 51: Guidelines for Writing Effective Requirements**

This slide is an introduction to the guidelines for writing effective requirements.

*Key Takeaway:* Guidelines for writing effective requirements are crucial for ensuring clarity, accuracy, and completeness.

**Slide 52: Understand Your Stakeholders**

One of the key tips to writing great requirements is understanding your stakeholders.

*Key Takeaway:* Identifying and involving all relevant stakeholders from the beginning, you can ensure that their needs and expectations are captured in the requirements.

**Slide 53: Understand What Is Needed**

There is a huge difference between want and need.

*Key Takeaway:* Rather than focusing on possible solutions, simply list what the system needs – the solution can come later.

**Slide 54: Remember the CONOPs**

The Concept of Operations (CONOPS) is a valuable artifact.

*Key Takeaway:* The CONOPS will help you write quality requirements by finding all the assumptions.

**Slide 55: Be Specific, But Not Too Specific**

Writing specific requirements is crucial to avoid ambiguity and misinterpretation.

*Key Takeaway:* Finding the right balance between specificity and flexibility is key to writing effective requirements.

**Slide 56: Give Requirements, Not Instructions**

Understand what is needed and create requirements from those needs.

*Key Takeaway:* If you understand your stakeholders' needs, writing requirements rather than instructions becomes an easier task.

**Slide 57: Include a Number, Name, and Description**

Each requirement should be uniquely identified with a number and name for easy reference and tracking.

*Key Takeaway:* A clear and concise description of the requirement is essential to ensure that all stakeholders have a common understanding of what is being requested.

**Slide 58: Ensure Traceability**

Traceability is vital in requirements management to establish relationships between requirements, design, implementation, and testing.

*Key Takeaway:* By tracing requirements throughout the project lifecycle, you can ensure that each requirement is satisfied and verified, leading to a successful project outcome.

**Slide 59: Include a Rationale**

A rationale (reason) justifies the inclusion of a specific requirement.

*Key Takeaway:* The rationale provides reviewers and implementers with additional information on the intent of the requirements and avoids confusion down the line.

**Slide 60: Use Proper Grammar**

Maintaining proper grammar in requirement documentation is crucial for clarity and consistency.

*Key Takeaway:* Using proper grammar will prevent costly mistakes due to confusion.

**Slide 61: Use a Standard**

Use a standard to ensure consistency while writing your requirements, choosing one that is right for your industry.

*Key Takeaway:* Using a standard to ensure consistency while writing your requirements, choosing one that is right for your industry.

**Slide 62: Example: Applying the Tips in Practice**

This slide shows an example of good requirement writing.

*Key Takeaway:* Understanding through example is a good way to comprehend how to write good requirements.

**Slide 63: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Introduction to Process Models
*   Traditional vs. Agile Requirements Engineering
*   Documenting Requirements
*   Quality Measurement in Requirements Engineering
*   Activity & Case Study

**Slide 64: Quality Measurement in Requirements Engineering**

This slide starts the discussion of quality measurement in requirements engineering.

*Key Takeaway:* Quality Measurement in Requirements Engineering is important for a successful project.

**Practice Quiz Questions:**

1.  Describe the INVEST model for user stories and explain why each characteristic is important.
2.  What is a Requirement Traceability Matrix (RTM), and why is it used in software development?
3.  Explain the difference between forward traceability and backward traceability.
4.  List and describe five guidelines for writing effective requirements.
5.  Why is it important to understand your stakeholders when writing requirements?

**Solutions to Practice Quiz Questions:**

1.  The INVEST model for user stories includes:
    *   *Independent:* The user story should be self-contained and not rely on other stories. This makes it easier to prioritize and implement.
    *   *Negotiable:* The user story is not a contract but a starting point for discussion and refinement.
    *   *Valuable:* The user story should provide value to the end-user or customer.
    *   *Estimable:* The development team should be able to estimate the effort required to implement the user story.
    *   *Small:* The user story should be small enough to be completed within a single iteration or sprint.
    *   *Testable:* The user story should have clear acceptance criteria that can be used to verify its implementation.
2.  A Requirement Traceability Matrix (RTM) is a document that maps and tracks the relationship between requirements, design, implementation, and testing. It is used to ensure that every requirement is properly implemented and validated.
3.  *Forward traceability* ensures that all requirements are implemented in the final product by mapping requirements to test cases. *Backward traceability* ensures that all design and development work is based on original requirements by mapping test cases back to requirements.
4.  Five guidelines for writing effective requirements:
    *   *Understand Your Stakeholders:* Capture their needs and expectations.
    *   *Understand What Is Needed:* Focus on needs, not solutions.
    *   *Be Specific, But Not Too Specific:* Balance clarity with flexibility.
    *   *Give Requirements, Not Instructions:* Provide enough information for cost-effective solutions.
    *   *Ensure Traceability:* Establish relationships between requirements and other project elements.
5.  Understanding your stakeholders is important because it ensures that their needs and expectations are captured in the requirements. This leads to more comprehensive and accurate requirements, resulting in a product that meets their needs.

## Software Requirement Engineering: Lecture 9 Breakdown

**Introduction**

This lecture focuses on quality measurement in requirements engineering, emphasizing key characteristics of high-quality requirements and the benefits they bring. It also covers compliance and industry standards and introduces a checklist approach for measuring quality.

**Slides 1-2: Title and Week Agenda**

This lecture is all about how to make sure your requirements are good quality.

*   Introduction to Process Models
*   Traditional vs. Agile Requirements Engineering
*   Documenting Requirements
*   Quality Measurement in Requirements Engineering
*   Activity & Case Study

**Slides 3-4: Quality Measurement in Requirements Engineering**

This slide introduces the key aspects of measuring the quality of requirements:

*   Completeness – Covers all necessary functionalities.
*   Consistency – No contradictions or conflicts.
*   Clarity – Free from ambiguity.
*   Feasibility – Can be implemented with available resources.
*   Testability – Can be verified through validation.
*   Traceability – Can be followed up.

*Analogy:* Think of these qualities as the key ingredients for a successful recipe. If any of these ingredients are missing or of poor quality, the final dish (software system) will suffer.

*Key Takeaway:* These six characteristics are essential for ensuring high-quality requirements.

**Slide 5: Completeness & Consistency**

This slide expands on completeness and consistency.

*   **Completeness:** All system aspects are covered (functional, non-functional, constraints).
    *   *Example:* A banking system must specify login, fund transfer, and transaction history features.
*   **Consistency:** No contradictions between requirements.
    *   *Example:* A system cannot have both "1-minute response time" and "real-time processing."

*Key Takeaway:* Complete requirements cover all necessary aspects, and consistent requirements avoid contradictions.

**Slide 6: Clarity & Feasibility**

This slide expands on clarity and feasibility.

*   **Clarity:** No vague terms like "user-friendly" or "fast."
    *   *Example:* "The system should load quickly." → "The system must load within 2 seconds."
*   **Feasibility:** Can be implemented given time, budget, and technology.
    *   *Example:* Requiring a mobile app to function without an internet connection may be infeasible.

*Key Takeaway:* Clear requirements are specific and unambiguous, and feasible requirements are realistic and achievable.

**Slide 7: Testability & Traceability**

This slide expands on testability and traceability.

*   **Testability:** Each requirement must be verifiable through test cases.
    *   *Example:* "The system must support 500 concurrent users" can be tested via load testing.
*   **Traceability:** Links requirements to design, implementation, and testing.
    *   *Example:* A Traceability Matrix tracks whether all functional requirements are tested.

*Key Takeaway:* Testable requirements can be validated through testing, and traceable requirements can be linked throughout the development lifecycle.

**Slide 8: Quality Measurement in Requirements Engineering**

Recall Covered in Lect 03 Week 02: Characteristics of Good Requirements.

*Key Takeaway:* This reminds us that the lecture builds on previous material.

**Slide 9: Characteristics of Good Requirements**

This slide lists the characteristics of good requirements.

Clear and Unambiguous

Complete

Consistent

Feasible

Testable (Verifiable)

Prioritized

Traceable

Modifiable

Measurable

*Key Takeaway:* These are the main characteristics of good requirements.

**Slides 10-18: Characteristics of Good Requirements**

These slides go into detail of each of the good requirement characteristics and gives examples.

*Key Takeaway:* Knowing these characteristics in detail will help to write good requirements.

**Slides 19-29: High-quality requirements- Benefits**

High-quality requirements have many benefits.

Reduced Ambiguity

Improved Communication

Accurate Cost Estimations

Enhanced Scope Management

Higher Quality Deliverables

Faster Development Cycles

Improved Testing

Easier Change Management

Enhanced Risk Management

Customer Satisfaction

Regulatory Compliance

Knowledge Preservation

*Analogy:* Think of high-quality requirements as the foundation of a building. A strong foundation leads to a stable and long-lasting structure.

*Key Takeaway:* High-quality requirements lead to numerous benefits across the entire software development lifecycle.

**Slides 30-32: Compliance & Industry Standards**

*   IEEE 830 – Software Requirements Specification (SRS)
*   ISO 25010 – Software Quality Measurement Framework
*   GDPR, HIPAA – Regulatory Compliance for Data Security
    *   *Example:* Healthcare software must comply with HIPAA security rules.

*Key Takeaway:* Compliance with industry standards is crucial for ensuring quality and meeting legal requirements.

**Slides 33-34: Measuring Quality – Checklist Approach**

Checklist for High-Quality Requirements:
☑️ Are all critical functionalities documented?
☑️ Do requirements avoid contradictions?
☑️ Can each requirement be verified?
☑️ Are constraints and risks identified?

*Key Takeaway:* A checklist approach can help ensure that requirements meet quality standards.

**Practice Quiz Questions:**

1.  List and describe six key characteristics of high-quality requirements.
2.  Explain why clarity is important in requirements engineering and provide an example of how to improve clarity.
3.  How does traceability contribute to quality in requirements engineering?
4.  Name three industry standards or regulations that are relevant to quality measurement in requirements engineering.
5.  Describe a checklist approach for measuring the quality of requirements.

**Solutions to Practice Quiz Questions:**

1.  Six key characteristics of high-quality requirements:
    *   *Completeness:* Covers all necessary functionalities.
    *   *Consistency:* No contradictions or conflicts.
    *   *Clarity:* Free from ambiguity.
    *   *Feasibility:* Can be implemented with available resources.
    *   *Testability:* Can be verified through validation.
    *   *Traceability:* Can be followed up.
2.  Clarity is important because it reduces ambiguity and misinterpretation, leading to a shared understanding among stakeholders. To improve clarity, replace vague terms with specific, measurable criteria. For example, change "The system should be fast" to "The system must respond to user inputs within 2 seconds under normal conditions."
3.  Traceability contributes to quality by linking requirements to design, implementation, and testing. This ensures that all requirements are addressed, changes are managed effectively, and the system meets its intended goals.
4.  Three industry standards or regulations relevant to quality measurement in requirements engineering:
    *   *IEEE 830:* Software Requirements Specification (SRS) standard.
    *   *ISO 25010:* Software Quality Measurement Framework.
    *   *GDPR/HIPAA:* Regulatory compliance for data security.
5.  A checklist approach for measuring the quality of requirements involves using a checklist to verify that requirements meet certain criteria. For example:
    *   Are all critical functionalities documented?
    *   Do requirements avoid contradictions?
    *   Can each requirement be verified?
    *   Are constraints and risks identified?

## Software Requirement Engineering: Lecture 10 Breakdown

**Introduction**

This lecture focuses on processes and process models in requirements engineering, highlighting the steps involved, the actors and stakeholders, and strategies for process improvement.

**Slides 1-2: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Processes & Process Models in Requirement Engineering
*   Requirement Engineering Process & Steps
*   Actors & Stakeholders in Requirement Engineering
*   Process Improvement for Requirement Engineering

**Slides 3-4: Processes & Process Models**

A process is a structured set of activities performed to achieve a specific goal. A process model is a structured framework or methodology that defines how processes should be carried out.

*Analogy:* Think of a process as the steps you take to bake a cake, and the process model as the recipe that guides you through those steps.

*Key Takeaway:* A process model provides a structured framework for carrying out processes.

**Slide 5: Processes & Process Models**

Example:
Software Development Life Cycle (SDLC) is a process model.
The activities within SDLC, like Requirements Engineering, Design, Implementation, Testing, Deployment, and Maintenance, are processes.

*Key Takeaway:* The SDLC is a process model that encompasses various processes.

**Slide 6: Requirement Engineering (RE) Process vs. RE Process Model**

Requirement Engineering Process consists of activities like elicitation, analysis, specification, validation, and management.
Requirement Engineering Process Model defines how these activities should be structured and followed systematically.

*Key Takeaway:* The RE process involves specific activities, while the RE process model defines how these activities are structured.

**Slide 7: Requirement Engineering Process (Example)**

Activities in Requirement Engineering:

*   Requirements Elicitation – Gathering requirements from stakeholders.
*   Requirements Analysis – Identifying inconsistencies, prioritizing needs.
*   Requirements Specification – Documenting requirements formally.
*   Requirements Validation – Ensuring correctness and completeness.
*   Requirements Management – Handling changes and updates to requirements.

*Key Takeaway:* These are the core activities involved in the requirements engineering process.

**Slide 8: Requirement Engineering Process Model (Example)**

*   **Waterfall Model in RE:** Elicitation → Analysis → Specification → Validation → Management (Linear approach).
*   **Agile Model in RE:** Iterative cycles of requirements gathering, refinement, and validation.

*Key Takeaway:* Different process models structure the RE activities in different ways.

**Slide 9: Analogy to Understand the Difference**

Process Model: Like a recipe (guideline on how to cook a dish).
Process: The actual steps you take to cook that dish.

*Key Takeaway:* This analogy reinforces the difference between a process and a process model.

**Slide 10: Processes & Process Models in Requirement Engineering**

SDLC Models focus on overall software development, where Requirement Engineering (RE) Process Models specifically address how requirements are gathered, analyzed, documented, and managed throughout the project.

*Key Takeaway:* RE Process Models are specific to requirements engineering and differ from overall SDLC models.

**Slide 11: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Processes & Process Models in Requirement Engineering
*   Requirement Engineering Process & Steps
*   Actors & Stakeholders in Requirement Engineering
*   Process Improvement for Requirement Engineering

**Slide 12: Requirement Engineering Process & Steps**

Phases of Requirement Engineering:
Requirement engineering ensures that software meets user needs.

*   Elicitation
*   Analysis
*   Specification
*   Validation

*Key Takeaway:* These phases are crucial for successful software development.

**Slide 13: Requirements Elicitation**

*   **Definition:** Gathering requirements from stakeholders.
*   **Activities:**
    *   Identifying stakeholders.
    *   Conducting interviews, surveys, and workshops.
    *   Observing existing systems.
*   **Objective:** Understand user needs and expectations.

*Key Takeaway:* Elicitation is about understanding what the stakeholders need.

**Slide 14: Requirements Analysis**

*   **Definition:** Processing gathered requirements.
*   **Activities:**
    *   Categorizing functional & non-functional requirements.
    *   Identifying constraints & dependencies.
    *   Resolving conflicting requirements.
*   **Objective:** Ensure clarity, feasibility, and completeness.

*Key Takeaway:* Analysis is about making sure the requirements are clear, feasible, and complete.

**Slide 15: Requirements Specification**

*   **Definition:** Documenting structured requirements.
*   **Activities:**
    *   Writing Software Requirements Specification (SRS).
    *   Using diagrams (Use Cases, Data Flow Diagrams).
    *   Maintaining traceability.
*   **Objective:** Provide clear, structured documentation.

*Key Takeaway:* Specification is about documenting the requirements in a structured way.

**Slide 16: Requirements Validation**

*   **Definition:** Ensuring correctness and completeness.
*   **Activities:**
    *   Stakeholder review and feedback.
    *   Prototyping and walkthroughs.
    *   Consistency and completeness checks.
*   **Objective:** Confirm requirements align with user expectations.

*Key Takeaway:* Validation is about confirming that the requirements meet user expectations.

**Slide 17: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Processes & Process Models in Requirement Engineering
*   Requirement Engineering Process & Steps
*   Actors & Stakeholders in Requirement Engineering
*   Process Improvement for Requirement Engineering

**Slide 18: What is an Actor in Software Development?**

An actor is any entity (human or system) that interacts with the software system.
Actors are essential for use case modeling as they define system interactions.

*Analogy:* Actors are like the characters in a play who interact with the stage (the software system).

*Key Takeaway:* Actors define how users or systems interact with the software.

**Slide 19: Types of Actors**

*   **Primary Actor:** Directly interacts with the system (e.g., User, Customer).
*   **Secondary Actor:** Supports system operations indirectly (e.g., Payment Gateway, API).
*   **System Actor (or External Actor):** External system that interacts with the software (e.g., Database, Third-party service).

*Key Takeaway:* Different types of actors have different roles in the system.

**Slide 20: Example of Actors in an Online Banking System**

*   **Customer (Primary Actor):** Logs in, checks balance, transfers funds.
*   **Bank Teller (Primary Actor):** Accesses customer accounts to assist with transactions.
*   **Banking System (Secondary Actor):** Processes transactions, updates balance.
*   **Regulatory Authority (External Actor):** Ensures compliance with financial regulations.

*Key Takeaway:* This example illustrates the different types of actors in a real-world system.

**Slide 21: What is a Stakeholder in Software Development?**

A stakeholder is any individual or entity that has an interest in the system and can affect or be affected by it.
Unlike actors, stakeholders may or may not interact directly with the system.

*Analogy:* Stakeholders are like the audience members who are affected by the play, even though they are not on the stage.

*Key Takeaway:* Stakeholders have an interest in the system, whether or not they interact with it directly.

**Slide 22: Key Stakeholders & Their Roles**

(Note: Detailed content not provided in the original file.)

*Key Takeaway:* N/A

**Slide 23: How Actors Affect System Design & Development?**

Actors influence:

*   **Functional Requirements:** What the system should do (e.g., Users requesting a “Forgot Password” feature).
*   **Non-Functional Requirements:** How the system should behave (e.g., Regulatory Authorities enforcing data security rules).
*   **System Architecture:** How different actors interact determines system complexity (e.g., APIs interacting with an e-commerce platform).

*Key Takeaway:* Actors influence various aspects of system design and development.

**Slide 24: Difference Between Actors & Stakeholders**

(Note: Table or detailed comparison not provided in the original file.)

*Key Takeaway:* N/A

**Slide 25: Week Agenda**

The agenda outlines the key topics covered in the lecture:

*   Processes & Process Models in Requirement Engineering
*   Requirement Engineering Process & Steps
*   Actors & Stakeholders in Requirement Engineering
*   Process Improvement for Requirement Engineering

**Slide 26: Process Improvement for Requirement Engineering**

Common Issues in Requirement Engineering:

*   Ambiguous or unclear requirements.
*   Changing requirements due to market shifts.
*   Lack of stakeholder communication.

*Key Takeaway:* These are common challenges in requirements engineering.

**Slide 27: Strategies for Process Improvement**

*   Implement Requirement Traceability Matrix (RTM).
*   Adopt Capability Maturity Model Integration (CMMI) for continuous improvement.
*   Use Agile & Iterative Approaches for flexibility.
*   Conduct Regular Reviews & Stakeholder Feedback.
*   Automate requirement tracking using tools like JIRA, IBM Rational DOORS.

*Key Takeaway:* These strategies can help improve the requirements engineering process.

**Slide 28: Key Takeaways**

*   Requirement Engineering ensures software meets user needs.
*   Various process models impact how requirements are handled.
*   Involving stakeholders is critical for success.
*   Continuous process improvement enhances requirement clarity and quality.
*   Tools and methodologies help streamline requirement management.

*Key Takeaway:* This slide summarizes the key takeaways from the lecture.

**Practice Quiz Questions:**

1.  What is the difference between a process and a process model in requirements engineering? Give an example of each.
2.  List and describe the four key phases of the requirements engineering process.
3.  What is an actor in software development, and how does it differ from a stakeholder?
4.  Give an example of a primary actor, a secondary actor, and an external actor in a library management system.
5.  Describe three strategies for process improvement in requirements engineering.

**Solutions to Practice Quiz Questions:**

1.  A *process* is a structured set of activities performed to achieve a specific goal, such as gathering requirements from stakeholders. A *process model* is a structured framework that defines how these activities should be carried out, such as the Waterfall model or the Agile model.
2.  The four key phases of the requirements engineering process are:
    *   *Elicitation:* Gathering requirements from stakeholders.
    *   *Analysis:* Processing gathered requirements to ensure clarity and completeness.
    *   *Specification:* Documenting structured requirements in an SRS.
    *   *Validation:* Ensuring correctness and completeness through stakeholder review.
3.  An *actor* is any entity (human or system) that interacts directly with the software system. A *stakeholder* is any individual or entity that has an interest in the system and can affect or be affected by it, whether or not they interact directly with the system.
4.  In a library management system:
    *   *Primary Actor:* Librarian (directly interacts with the system to manage books and users).
    *   *Secondary Actor:* Payment Gateway (supports system operations by processing payments for overdue fines).
    *   *External Actor:* Database (external system that stores and provides data to the library management system).
5.  Three strategies for process improvement in requirements engineering:
    *   *Implement Requirement Traceability Matrix (RTM):* To ensure all requirements are covered in testing.
    *   *Use Agile & Iterative Approaches:* For flexibility and continuous feedback.
    *   *Conduct Regular Reviews & Stakeholder Feedback:* To identify and address issues early.